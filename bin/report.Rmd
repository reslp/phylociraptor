---
title: phylociraptor           
output: 
    html_document:
        toc: TRUE
        toc_float: TRUE
        toc_side: left
---

```{css toc-content, echo = FALSE}
#TOC {
  left: 100px;
  margin: 20px 0px 25px 0px;
}

.main-container {
    margin-right: 100px;

}
div.main-container {
  max-width: 100%;
}
```

## {.tabset .tabset-fade}

```{r setup, echo=FALSE, message=FALSE}
##IMPORTANT: This now takes into account hashing information. However there are still a few quirks which need to be fixed:
# SOLVED - 1. There is a problem with trimmed and filtered alignment numbers. Something seems to be off with the stats files...
# 2. njtree is not yet in the report. This will have to be written from scratch, as there is (currently) no statistics file which can be use.
# 3. Further tests are necessary to see if the report script completes correctly if some files are missing
# 4. Analyses hashes should be better represented in the report
# 5. The logfile printing needs to be improved
library(kableExtra)
library(formattable)
library(dplyr)
library(knitr)
#library(tidyverse)
library(ggplot2)
library(viridis)
library(readr)
library(plotly)
library(stringr)
library(data.table)
library(ggpubr)
library(gridExtra)
library(RColorBrewer)
library(yaml)
library(DT)
library(reticulate)
library(patchwork)
use_condaenv(condaenv="base", conda = "/usr/local/reticulateminiconda/bin/conda")

args <- commandArgs(trailingOnly=TRUE)
wd <- args[1] # get working directory
config_file_path <- paste0("../",args[2])
config_data <- read_yaml(config_file_path)
pars_sites <-config_data$trimming$min_parsimony_sites
pars_sites <- strtoi(pars_sites)
rcv_cutoff <-config_data$trimming$max_rcv_score
rcv_cutoff <- as.double(rcv_cutoff)

parsimony_cutoff <- 3
# check if seed was specified or not:
if (is.null(config_data$seed) || config_data$seed == "") {
	config_data$seed <- "random"
} else {
	set.seed(strtoi(config_data$seed))
} 

#knitr::opts_chunk$set(dev = 'pdf')
# function to convert seconds to better formated time:
# from here: https://stackoverflow.com/a/51156986

dhms <- function(t){
    paste(t %/% (60*60*24), "days"
         ,paste(formatC(t %/% (60*60) %% 24, width = 2, format = "d", flag = "0")
               ,formatC(t %/% 60 %% 60, width = 2, format = "d", flag = "0")
               ,formatC(t %% 60, width = 2, format = "d", flag = "0")
               ,sep = ":"
               )
         ,sep=" ")
}

```

```{python, calculate-hashes-python, echo=FALSE, message=FALSE}
import sys
import yaml
from libphylociraptor.hashing import *
from libphylociraptor.check import *
all_hashes = {}

def parse_config_file(cf):
	with open(cf) as f:
		data = yaml.load(f, Loader=yaml.FullLoader)
	return data
for mode in steps_to_check:
	all_hashes[mode] = collect_hashes(mode, parse_config_file(r.config_file_path), r.config_file_path, debug=False, wd=r.wd)
current_hash = all_hashes["orthology"]["orthology"]["global"]
# save configfile data from yaml so we can use it later:
config_data = parse_config_file(r.config_file_path)
```

`r version <- read.table("../.version", header=F)`
`r ver <- " - version: "`

**`r paste0("Analysis report - ", format(Sys.time(), '%d %B, %Y - %R %Z'), ver, version)`**
 
```{r checkinput_general, echo=FALSE}
# set input file names:
busco_overview_image <- ""

#  alignment statistics information
alignment_statistics_file <- "../results/statistics/statistics_alignments.txt"
trimmed_alignment_statistics_file <- "../results/statistics/statistics_trimmed.txt"
filtered_alignment_statistics_file <- "../results/statistics/statistics_filtered.txt"
filtered_gene_information_file <- "../results/statistics/alignment_filter_information.txt"

align_trim_overview_statistics_file <- "../results/statistics/trim-filter-overview.txt"


downloaded_genomes_statistics_file <- "../results/statistics/downloaded_genomes_statistics.txt"
failed_genome_downloads_file <- "../results/downloaded_genomes/not_downloaded.txt"
successfull_genome_downloads_file <- "../results/downloaded_genomes/successfully_downloaded.txt"
local_species_file <- "../results/statistics/local_species.txt"

best_models_file <- "../results/modeltest/best_models.txt"

tree_statistics_file <- "../results/statistics/tree_statistics.txt"
speciestree_statistics_file <- "../results/statistics/speciestree_statistics.txt"
runlog_file <- "../results/statistics/runlog.txt"

#read benchmarking results

benchmarkfile_run_busco <- "../results/statistics/benchmark_all_busco_runs.bench"

# global variables:

base_size <- 12
```


# Setup

```{r genomes, echo=FALSE}
if (file.exists(failed_genome_downloads_file))
{
  if (file.size(failed_genome_downloads_file) > 0) {
    failed_sp <- read.table(failed_genome_downloads_file, header=F)
    failed <- paste(failed_sp$V1, sep="\n")
  } else { failed <- numeric()}
} else {
  failed <- numeric()
}

if (file.exists(successfull_genome_downloads_file)){
  if (file.size(successfull_genome_downloads_file) > 0) {
    success_sp <- read.table(successfull_genome_downloads_file, header=F)
    success <- paste(success_sp$V1, sep="\n")
  } else {success <- numeric()}
} else {
  success <- numeric()
}

if (file.exists(local_species_file)){
  if (file.size(local_species_file) > 0) {
  local_sp <- read.table(local_species_file, header=F)
  local <- paste(local_sp$V1, sep="\n")
  } else {local <- numeric()}
} else {
  local <- numeric()
}

total <- length(failed) + length(success) + length(local)

```


**Location of genomes files:** 

```
results/assemblies
```

**Total number of included genomes:** `r total`    
**Locally provided genomes:** `r length(local)`    
**Successfully downloaded genomes:** `r length(success)`    
**Failed species downloads:** `r length(failed)`    
**Not downloaded:**<br />`r failed`    

**Information on successfully downloaded genomes:**
```{r genome_stats, echo=F, out.height=500}
info <- ""
if (file.exists(downloaded_genomes_statistics_file))
{
  if (file.size(downloaded_genomes_statistics_file) != 0) {
     data <- read.csv(downloaded_genomes_statistics_file, sep="\t", header=T, row.names=NULL)
  } else {
    info <- "*No information about downloaded genomes found. Maybe you only have local species?*"
  }
  colnames(data) <- c(colnames(data)[2:length(colnames(data))], " ")
  
  datatable(data, class="display" ,rownames=F, extensions = c('Buttons',"FixedColumns"), options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print'), scrollX=T, fixedColumns=list(leftColumns=1))
) 
} else {
  info <- "*No information about downloaded genomes found. Did you run phylociraptor setup ?*"
}

```
`r info`



```{python, echo=FALSE}
busco_set = config_data["orthology"]["busco_options"]["set"]
#enable this for debugging hash related problems
#for mode in steps_to_check:
#	print(mode)
#	print(all_hashes[mode][mode]["global"])
#	print(all_hashes[mode][mode])
#	print(" ")

orthology_hash = all_hashes["orthology"]["orthology"]["global"]
forthology_hash = all_hashes["filter-orthology"]["filter-orthology"]["global"]
```

# Orthology

Analysis hash for step orthology: `r py$orthology_hash`\
Analysis hash for step filter-orthology: `r py$forthology_hash`

```{r, echo=FALSE, results="asis"}
# orthology statistics file:
#busco_set_dir <- list.dirs("../results/orthology/busco/busco_set/",recursive=F)
busco_overview_file <- paste0("../results/orthology/busco/busco_set/",py$busco_set,"/dataset.cfg")
busco_summary_file <- "../results/statistics/busco_summary.txt"
orthology_filtering_genomes_file <- paste0("../results/statistics/orthology_filtering_genomes_statistics.", py$forthology_hash,".txt")
orthology_filtering_genes_file <- paste0("../results/statistics/orthology_filtering_gene_statistics.",py$forthology_hash,".txt")


if (file.exists(busco_overview_file)){
  busco_overview <- read.table(busco_overview_file, sep="=", header=F)
  busco_set <- busco_overview$V2[busco_overview$V1 == "name"]
  nbuscos <- busco_overview$V2[busco_overview$V1 == "number_of_BUSCOs"]
  
  
} else {
  busco_set <- "unknown (maybe BUSCO set was not downloaded yet)"
  nbuscos <- "unknown (maybe BUSCO set was not downloaded yet)"
}

# display of benchmarking results needs more work
#if (file.exists(benchmarkfile_run_busco)) {
#  busco_bench_df <- read.table(benchmarkfile_run_busco, sep="\t", header=F)
#  colnames(busco_bench_df) <- c("job", "seconds", "time", "max_vss", "max_vms", "max_uss", "max_pss", "io_in", "io_out", "mean_load")
#  busco_bench_df$minutes <- busco_bench_df$seconds/60
#  busco_bench_df$job <- str_replace(busco_bench_df$job, "run_busco_", "")
#  busco_bench_df$job <- str_replace(busco_bench_df$job, ".txt", "")
#} else {
#  busco_bench_df <- "not_found"
#}

if (file.exists(orthology_filtering_genomes_file)) {
  ortho_filter_genomes <- read.table(orthology_filtering_genomes_file, sep="\t", header=F)
  colnames(ortho_filter_genomes) <- c("sample", "status", "completeness", "cutoff")
  failed_genomes <- ortho_filter_genomes$sample[ortho_filter_genomes$status == "FAILED"]
  cutoff <- ortho_filter_genomes$cutoff[1]
} else {
  failed_genomes <- numeric()
  cutoff <- numeric()
}
if (file.exists(orthology_filtering_genes_file)) {
  ortho_filter_genes <- read.table(orthology_filtering_genes_file, sep="\t", header=F)
  colnames(ortho_filter_genes) <- c("gene", "status", "nseqs", "cutoff")
  failed_genes <- ortho_filter_genes$gene[ortho_filter_genes$status == "FAILED"]
  cutoff_gene <- ortho_filter_genes$cutoff[1]
} else {
  failed_genes <- numeric()
  cutoff_gene <- numeric()
}

```
Orthologous genes were inferred using BUSCO.

**Location of BUSCO results:** 

```
results/orthology/busco/busco_runs/`r py$busco_set`.`r py$orthology_hash`
```

**Used BUSCO set:** `r py$busco_set`

**Total number of BUSCO genes in BUSCO set:** `r nbuscos`  
**Number of BUSCO genes recovered in too few (`r cutoff_gene`) samples:** `r length(failed_genes)`  
**BUSCO genes below threshold:**  
`r if(length(failed_genes)==0){"none"}else{failed_genes}`

**Number of samples with single-copy BUSCO score below threshold (`r cutoff`):** `r length(failed_genomes)`  
**Genomes below threshold:**  
`r failed_genomes`


**Orthology overview table:**  
```{r busco_stats, echo=FALSE, message=F, fig.width=8, warning=F, results="asis"}
if (file.exists(busco_summary_file))
{	
  data <- read.table(busco_summary_file, sep="\t", header=T)
  data <- data[ order(data$species), ]
  rownames(data) <- NULL
  # clean up name
  spnames <- c()
  for (element in strsplit(data$species, "/")) {
  spnames <- c(spnames, element[5])
  }
  data$species <- spnames
  data$total <- NULL
  data$complete <- NULL
  rownames(data) <- data$species
  data$species <- NULL
  data2 <- mutate_all(data, function(x) as.numeric(as.character(x)))

  data <- data2
  # new plotting:
  datatable(data, class="display" ,rownames=T, extensions = c('Buttons'),
  options = list(dom = 'Bfrtip', buttons = list('copy', 'csv', 'excel', list(extend = "pdf",title = "Orthology overview", pageSize = "A4",orientation = "landscape"), 'print'))) %>% 
  formatStyle("single_copy", background = styleColorBar(c(0,max(data)), '#b2df8a'), backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat', backgroundPosition = 'center') %>% formatStyle("duplicated", background = styleColorBar(c(0, max(data)), '#a6cee3'), backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat', backgroundPosition = 'center') %>% formatStyle("fragmented", background = styleColorBar(c(0, max(data)), '#fdbf6f'), backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat', backgroundPosition = 'center') %>% formatStyle("missing", background = styleColorBar(c(0, max(data)), '#fb9a99'), backgroundSize = '98% 88%', backgroundRepeat = 'no-repeat', backgroundPosition = 'center')
} else {
	cat("no information on BUSCO runs found. Did you run phylociraptor orthology?")
}


```

```{r, include=TRUE, fig.align="center", echo=F}
#out.width="1.0\\linewidth"
if (file.exists(busco_overview_image)) {
  include_graphics(busco_overview_image)
} 
```


```{python, echo=FALSE}
aligners = []
taligners = []
faligners = []
for aligner in all_hashes["align"]["align"]["per"]:
	f = "../results/statistics/align-" + aligner + "." + all_hashes["align"]["align"]["per"][aligner]
	if os.path.exists(f):
		aligners.append(f)
for trimmer in all_hashes["filter-align"]["filter-align"]["per"]:
	for aligner in all_hashes["filter-align"]["filter-align"]["per"][trimmer]:
		tf = "../results/statistics/trim-" + aligner + "-" + trimmer + "." + all_hashes["filter-align"]["filter-align"]["per"][trimmer][aligner]
		if os.path.exists(tf):
			taligners.append(tf)
		ff = "../results/statistics/filter-" + aligner + "-" + trimmer + "." + all_hashes["filter-align"]["filter-align"]["per"][trimmer][aligner]
		if os.path.exists(ff):
			faligners.append(ff)
```


# Alignments {.tabset .tabset-fade .tabset-pills}

## full alignments

**Location of alignment files:** 
```
results/alignments/full
```


```{r stats_alignments, echo=FALSE}
dirs <- py$aligners
read_my_overview <-function(dat) {
	return(read.csv(dat,header=F,sep="\t"))
}

if (length(dirs) != 0) {
	dat <- list()
	i <- 1
	for (dir in dirs) { # this code needs to be expanded and the dataframe integrated into the one created in the next chunk
		files <- list.files(path=dir, pattern="*overview*", full.names=T)
		data <- do.call(rbind,lapply(files,read_my_overview))	
		dat[[i]] <- data
		i <- i + 1
	}
	
	data_combined_overview <- do.call(cbind, dat)
}
```


```{r stats_alignments2, echo=F, results="asis"} 
if (length(dirs)==0) {cat("<br><b> Alignment statistic files not found. Did you run phylociraptor align?</b>\n")} else {
	read_my_csv <-function(dat) {
		return(read.csv(dat,header=T,sep="\t"))
	}
	cat("<br><b>Used aligner(s) and settings:</b><br>")
  	for (nalan in 1:length(data_combined_overview[1,])) {
  		aligner_info <- paste(head(strsplit(data_combined_overview[1,nalan], " ")[[1]], length(strsplit(data_combined_overview[1,nalan], " ")[[1]])-1), collapse= " ")
  		aligner_info <- gsub("None", "", aligner_info)
		cat(paste0("<b>", as.character(nalan), ". </b>", aligner_info, "<br>"))
  	}
	cat(paste0("<br><b>Parsimony informative sites cutoff (nparsimony): </b>", pars_sites))
	cat(paste0("<br><b>Relative composition variability (rcv) cutoff: </b>", rcv_cutoff, "<br>"))
	dat <- list()
	i <- 1
	for (dir in dirs) {
		files <- list.files(path=dir, pattern="*statistics*", full.names=T)
		data <- do.call(rbind,lapply(files,read_my_csv))	
		cat(paste0("<br><b>Number of alignments for ", strsplit(dir,split="align-")[[1]][2],": </b>", nrow(data), "\n"))
		if (i ==1) {
			data <- data[,c(1,4,5,7,8,6,9)] #select and reorder columns
		} else{
			data <- data[,c(4,5,6,8,6,9)] # select and reorder columns
		}
		rows <- which(data$nparsimony < pars_sites)
		data <- as.data.frame(data)
		dat[[i]] <- data 
		i <- i + 1
	}
	
	data_combined <- do.call(cbind, dat)
	get_headers <- function(dirs) {
		names <- c()
		for (dir in dirs) {
			n <- tail(str_split(dir, "-")[[1]], n=1)
			names <- c(names, n)
		}
		return(names)
	}
	
	cat("<br><br><b>Overview of individual full alignments:</b>\n")
	generate_table_html <- function(alitrim, coldata) {
	
		htmltable <- 
		"
		<table class='display'><thead><tr><th colspan='1'></th>
		"
		#first get colnames of aligners and trimmers:
		for (al in alitrim) {
			htmltable <- paste0(htmltable, "<th colspan='6' style='border-right: solid 2px;'>", al, "</th>")
		}
		# fill HTML till we get to next level colnames:
		htmltable <- paste0(htmltable,"</tr><tr><th colspan='1'> </th>")
		for (i in 1:length(alitrim)-1) {
			for (col in coldata) {
				htmltable <- paste0(htmltable, "<th>", col,"</th>")
			}
		}
		# add missing html at the end of table:
		htmltable <- paste0(htmltable,"</tr></thead></table>")
		return(htmltable)
	}

	sketch <- generate_table_html(get_headers(dirs),c('length', 'nseqs', 'nvar', 'nfixed','nparsimony', 'rcv')) # names of columns needs to correspond the above order!

        datatable(data_combined, container=sketch, escape=FALSE, class = "cell-border stripe", rownames = F, filter="top", editable=TRUE, extensions = c("Buttons","FixedColumns"), options = list(dom="Bfrtip", buttons=list("copy", "csv", "excel", list(extend = "pdf",title = "Full alignments overview", pageSize = "A4",orientation = "landscape"), "print"), scrollX=T, fixedColumns = list(leftColumns = 1))) %>% formatStyle(c(7,13), `border-right` = "solid 2px")
}
```

## trimmed alignments

**Location of trimmed alignment files:** 
```
results/alignments/trimmed
```

```{r stats_trimmed, echo=FALSE, results="asis"}
if (exists("pars_sites") == TRUE) {
	cat(paste0("<b> Parsimony informative sites cutoff: </b>", pars_sites))
	parsimony_cutoff <- pars_sites 
} else { parsimony_cutoff <- 100000} # in case this can not be determined from the overview stats file, use high value to flag nothing

if (exists("rcv_cutoff") == TRUE) {
	cat(paste0("<br><b>Relative composition variability (rcv) cutoff: </b>", rcv_cutoff, "<br>"))
} else { rcv_cutoff <- 1} # in case this can not be determined from the overview stats file, use high value to flag nothing
```


```{r stats_trimmed2, echo=FALSE, warning=FALSE, results="asis"}
dirs <- py$taligners

if (length(dirs)==0) {
cat("<br><b> Trimming statistic files not found. Did you run phylociraptor filter-align?</b>\n")
} else {
	read_my_csv <-function(dat) {
		return(read.csv(dat,header=T,sep="\t"))
	}
	
	dat <- list()
	i <- 1
	for (dir in dirs) {
		files <- list.files(path=dir, pattern="*statistics*", full.names=T)
		data <- do.call(rbind,lapply(files,read_my_csv))	
		cat(paste0("<br><b>Number of trimmed alignments for ", strsplit(dir,split="trim-")[[1]][2],": </b>", nrow(data), "\n"))
		data <- data[,c(1,4,5,7,8,6,9)]
		data <- as.data.frame(data)
		dat[[i]] <- data 
		i <- i + 1
	}
	
	multi_merge <- function(d) {
		df <- d[[1]]
		if (length(d) >= 2) {
			for (i in 2:length(dat)) {
				df <- merge(df, d[[i]], by="alignment", all=T, suffixes=c("",""))
			}
		}
		return(df)
	}

	data_combined <- do.call(multi_merge, list(dat))
	data_combined[is.na(data_combined)] = ""
	get_headers_trimmer <- function(dirs) {
		names <- c()
		for (dir in dirs) {
			vec <- str_split(dir, "-")[[1]]
			aligner <- vec[length(vec)-1]	
			trimmer <- tail(str_split(dir, "-")[[1]], n=1)
			names <- c(names, paste0(aligner,"-",trimmer))
		
		}
		return(names)
	}
		
	cat("<br><br><b>Overview of individual trimmed alignments:</b>\n")

	sketch <- generate_table_html(get_headers_trimmer(dirs),c('length', 'nseqs', 'nvar', 'nfixed', 'nparsiomny', 'rcv'))

        datatable(data_combined, container=sketch, escape=FALSE, class = "cell-border stripe", rownames = F, filter="top", editable=TRUE, extensions = c("Buttons","FixedColumns"), options = list(dom="Bfrtip", buttons=list("copy", "csv", "excel", list(extend = "pdf",title = "Trimmed alignments overview", pageSize = "A4",orientation = "landscape"), "print"), scrollX=T, fixedColumns = list(leftColumns = 1))) %>% formatStyle(c(7,13), `border-right` = "solid 2px")
	
}
```


## filtered alignments

**Location of filtered alignment files:** 
```
results/alignments/filtered
```

```{r stats_filtered, echo=FALSE, results="asis"}
if (exists("pars_sites") == TRUE) {
	cat(paste0("<b> Parsimony informative sites cutoff: </b>", pars_sites))
	parsimony_cutoff <- pars_sites 
} else { parsimony_cutoff <- 100000} # in case this can not be determined from the overview stats file, use high value to flag nothing

if (exists("rcv_cutoff") == TRUE) {
	cat(paste0("<br><b>Relative composition variability (rcv) cutoff: </b>", rcv_cutoff, "<br>"))
} else { rcv_cutoff <- 1} # in case this can not be determined from the overview stats file, use high value to flag nothing
```

```{r stats_filtered2, echo=FALSE, warning=FALSE, results="asis"}
dirs <- py$faligners

if (length(dirs)==0) {
cat("<br><b> Filtering statistic files not found. Did you run phylociraptor filter-align?</b>\n")

} else {
	read_my_csv <-function(dat) {
		return(read.csv(dat,header=T,sep="\t"))
	}
	
	dat <- list()
	i <- 1
	for (dir in dirs) {
		files <- list.files(path=dir, pattern="*statistics*", full.names=T)
		data <- do.call(rbind,lapply(files,read_my_csv))	
		cat(paste0("<br><b>Number of filtered alignments for ", strsplit(dir,split="filter-")[[1]][2],": </b>", nrow(data), "\n"))
		data[,6] <- cell_spec(data[,6], background = ifelse(data[,6] < parsimony_cutoff, "red", ""))
		data <- data[,c(1,4,5,7,8,6,9)]
		data <- as.data.frame(data)
		dat[[i]] <- data 
		i <- i + 1
	}
	
	multi_merge <- function(d) {
		df <- d[[1]]
		if (length(d) >= 2) {
			for (i in 2:length(dat)) {
				df <- merge(df, d[[i]], by="alignment", all=T, suffixes=c("",""))
				#df <- full_join(df, d[[i]], by="alignment", suffix = c(".x", ".y"))
			}
		}
		return(df)
	}

	#data_combined <- merge(dat[[1]], dat[[2]], all=T, by="alignment")
	data_combined <- do.call(multi_merge, list(dat))
	data_combined[is.na(data_combined)] <- NA

	#rownames(data_combined) <- data_combined$alignment
	#data_combined$alignment <- NULL
	
	#print(data_combined %>% kbl())	
	
	cat("<br><br><b>Overview of individual filtered alignments:</b>\n")
	sketch <- generate_table_html(get_headers_trimmer(dirs),c('length', 'nseqs', 'nvar', 'nfixed', 'nparsimony', 'rcv'))

	render <- JS(
  	"function(data, type, row) {",
  	"  if(type === 'sort' && data === null) {",
  	"    return 999999;",
  	"  }",
  	"  return data;",
  	"}"
	)

        datatable(data_combined, container=sketch, escape=FALSE, class = "cell-border stripe", rownames = F, filter="top", editable=TRUE, extensions = c("Buttons","FixedColumns"), options = list(columnDefs = list(list(targets=1, render=render)),dom="Bfrtip", buttons=list("copy", "csv", "excel", list(extend = "pdf",title = "Filtered alignments overview", pageSize = "A4",orientation = "landscape"), "print"), scrollX=T, fixedColumns = list(leftColumns = 1))) %>% formatStyle(c(7,13), `border-right` = "solid 2px")
	
	#data_combined %>% kbl(escape=F) %>% add_header_above(get_headers_aligner(dirs)) %>% add_header_above(get_headers_trimmer(dirs)) %>% kable_paper("hover", full_width = F) %>% scroll_box(width = "100%", height = "600px") 
	
}
```

<details><summary>Show additional figures</summary>

```{r ext-figures, echo=FALSE, fig.width = 11.7, message=FALSE, warning=FALSE}
f <- list.files(path="../results/statistics/", pattern="filtered-alignments-stats-*", full.names=T)

#filter-mafft-trimal.250586f87f
if (identical(f, character(0)) == FALSE) {
	data <- read.csv(f, sep='\t', row.names=NULL)
	data$alignment <- NULL  # this is wrongly formatted in the csv. needs to be corrected
	colnames(data) <- c("combination", "alignment", "length", "nseqs", "nparsimony", "nvariable", "nfixed", "rcv")	
	plotlist <- list()
	i <- 1
	cols <- c("#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#cccccc")
	for (col in colnames(data))
	{
	  if (col == "combination" || col == "alignment") {next}
	
	  p <- ggplot(data,aes(x=.data[[col]]))+ geom_density(aes(color = combination), show.legend = FALSE)+stat_density(aes(x=.data[[col]], color=combination), geom="line",position="identity") + scale_color_manual(values=cols)
	  p <- p + ggtitle(paste0(col)) 
	  plotlist[[i]] <- p
	  i <- i + 1
	}
	p #+ theme(legend.key = element_rect(fill = cols))
	pp <- ggarrange(plotlist=plotlist, common.legend = TRUE, legend = "bottom")
	pp <- annotate_figure(pp, top = text_grob(paste0("Statistics of filtered alignments"), color = "black", face = "bold", size = 14))
	print(pp)
}
# this is the code for plotting pairwise combinations of different features of the alignments
# it is currently commented out but kept here for the future when this will be added properly.
# currently this code is very slow and displaying the resulting graph in the HTML is trick because there are many subplots.
#
#all_combs <- expand.grid(unique(data$combination), unique(data$combination))
#
#for (what in colnames(data))
#{
#  if (what == "combination" || what == "alignment") {next}
#  print(paste0("Working on: ", what))
#  plotlist_single <- list()
#  j <- 1
#  previous_y <- ""
#  for (n in 1:nrow(all_combs)){
#    
#    combs <- c(as.character(all_combs[n,1]), as.character(all_combs[n,2]))
#    if (combs[1] == combs[2]){
#      p <- ggplot() + theme_void()
#      plotlist_single[[j]] <- p
#      j <- j + 1
#      next
#    }
#    smalld <- data[data$combination == combs,]
#    
#    coln <- c("alignment", combs)
#    refdata <- data.frame("alignment" = character(), comb1 = numeric(0), comb2 = numeric(0))
#    
#    i <- 1
#    for (al in unique(smalld$alignment)) {
#      row <- c(al)
#      for (comb in combs) {
#        #print(data[data$combination == comb & data$alignment == al, "nvariable"] )
#        if (identical(data[data$combination == comb & data$alignment == al, what], integer(0))) {
#          row <- c(row, NA)
#        } else {row <- c(row, as.numeric(data[data$combination == comb & data$alignment == al, what]))}
#        
#      }
#      #print(row)
#      refdata[i, ] <- row
#      i <- i + 1
#    }
#    # needs to be converted to numeric again:
#    refdata[,2] <- as.numeric(refdata[,2])
#    refdata[,3] <- as.numeric(refdata[,3])
#    refdata <- na.omit(refdata)
#    p <- ggplot(refdata, aes(x=comb1, y=comb2)) + geom_point() + xlab(combs[1]) 
#    if (previous_y != combs[2]) {
#      p <- p + ylab(combs[2])
#    } else {
#      p <- p + theme(axis.title.y=element_blank())
#    }
#    previous_y <- combs[2]
#    plotlist_single[[j]] <- p
#    j <- j + 1
#    
#  }
#  
#  # get common axis ranges: (does not yet work)
#  p_ranges_x <- c()
#  p_ranges_y <- c()
#  for (x in 1:length(plotlist)){
#    if (is.null(ggplot_build(plotlist[[x]])$layout$panel_scales_x[[1]]$range$range) == F & is.null(ggplot_build(plotlist[[x]])$layout$panel_scales_y[[1]]$range$range) == F) {
#      p_ranges_x <- c(p_ranges_x, ggplot_build(plotlist[[1]])$layout$panel_scales_x[[1]]$range$range)
#      p_ranges_y <- c(p_ranges_y, ggplot_build(plotlist[[1]])$layout$panel_scales_y[[1]]$range$range)    
#    }
#  }
#  finalp <- ggpubr::ggarrange(plotlist = plotlist_single, ncol= 9, nrow=9) + plot_annotation(title = paste0("Pairwise comparison of ", what))
#  
#  finalp <- finalp + xlim(0, max(p_ranges_x)) + ylim(0, max(p_ranges_y))
#  
#  #pdf(file=paste0("pairwise-", what, ".pdf"), width=20, height=20)
#  print(finalp)
#  #dev.off()
#}

```
</details>




# Modeltesting

```{python, echo=FALSE}
faligners = []
gtfilter = []
for trimmer in all_hashes["modeltest"]["modeltest"]["per"]["iqtree"]:
	for aligner in all_hashes["modeltest"]["modeltest"]["per"]["iqtree"][trimmer]:
		f = "../results/modeltest/best_models_" + aligner + "_" + trimmer + "." + all_hashes["modeltest"]["modeltest"]["per"]["iqtree"][trimmer][aligner] + ".txt"
		if os.path.exists(f):
			faligners.append(f)
			gtfilter.append("../results/modeltest/genetree_filter_" + aligner + "_" + trimmer + "." + all_hashes["modeltest"]["modeltest"]["per"]["iqtree"][trimmer][aligner] + ".txt")
```

**Location of modeltesting files:** 
```
results/modeltest
```

**Overview of individual modeltest results:**
```{r stats_modeltest, echo=FALSE, out.width="50%", warning=F, fig.align="center"}
#files <- list.files(path="../results/modeltest/", pattern ="best_models_*", recursive=F)
files <- py$faligners
multi_merge <- function(d) {
	df <- d[[1]]
	if (length(d) >= 2) {
		for (i in 2:length(dat)) {
			df <- merge(df, d[[i]], by="alignment", all=T, suffixes=c("",""))
			#df <- full_join(df, d[[i]], by="alignment", suffix = c("", ""))
		}
	}
	return(df)
}
if (length(files) > 0) {
	i <- 1
	dat <- list()
	all_genes <- c()
	names <- c("alignment")
	titles <- c()
	plots <- list()
	models <- c()
	for (file in files) {
		# get reusable and meaningful name
		title <- str_split(file, "_")[[1]][3:4]
		# use other stringsplit function which supports fixed=T
		title[2] <- strsplit(title[2], ".", fixed=T)[[1]][1]
		title <- paste(title, collapse="-")
 		names <- c(names, title)
		titles <- c(titles, title)
		dat[[i]] <- read.table(file, sep="\t", header=F)
  		colnames(dat[[i]]) <- c("alignment", "model")
  		all_genes <- c(all_genes,dat[[i]]$alignment)
		models <- c(models, unique(dat[[i]]$model))
		i <- i + 1
	}
	# get unqiue number of models in dataset and create colors for them:
	models <- unique(models)
	if (length(models) <= 11) {
		# prettier colors when there are not too many different models
		cols <- brewer.pal(length(models), "BrBG")	
	} else {
		# we need more colors
		color <- grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
		cols <- sample(color, length(models))
	}
	names(cols) <- models
	for (i in 1:length(dat)) {
		dd <- as.data.frame(table(dat[[i]]$model))
		colnames(dd) <- c("model", "count")
		p <- ggplot(dd, aes(x="", y=count, fill=model)) + geom_bar(stat="identity", width=1) + coord_polar("y", start=0) + theme_void() + ggtitle(titles[i]) + scale_fill_manual(limits=models, values=cols)

		plots[[i]] <- p
	}
	if (length(plots) == 4) {
	print(ggarrange(plots[[1]], plots[[2]], plots[[3]], plots[[4]], common.legend = TRUE, legend="right"))
	}
	if (length(plots) == 3) {	
	print(ggarrange(plots[[1]], plots[[2]], plots[[3]], common.legend = TRUE, legend="right"))
	}
	if (length(plots) == 2) {	
	print(ggarrange(plots[[1]], plots[[2]], common.legend = TRUE, legend="right"))
	}
	if (length(plots) == 1) {	
	print(ggarrange(plots[[1]], common.legend = TRUE, legend="right"))
	}
	data_combined <- do.call(multi_merge, list(dat))
	colnames(data_combined) <- names
	#data_combined %>% kbl(escape=F) %>% kable_paper("hover", full_width = F)%>% scroll_box(width = "100%", height = "600px")	
        datatable(data_combined,  escape=FALSE, class = "cell-border stripe", rownames = F, filter="top", editable=TRUE, extensions = c("Buttons","FixedColumns"), options = list(dom="Bfrtip", buttons=list("copy", "csv", "excel", list(extend = "pdf",title = "Best substitution models overview", pageSize = "A4",orientation = "landscape"), "print"), scrollX=T, fixedColumns = list(leftColumns = 1)))
}
```




# Genetrees

**Location of gene trees:** 
```
results/modeltest
```

```{r stats_genetrees, message=FALSE, echo=FALSE, warning=FALSE, results="asis"}
p <- "" #have to do this so plotting does not fail when there is no data
#files <- list.files(path="../results/modeltest/", pattern ="genetree_filter_*", recursive=F)
files <- py$gtfilter
multi_merge <- function(d) {
	df <- d[[1]]
	if (length(d) >= 2) {
		for (i in 2:length(dat)) {
			df <- merge(df, d[[i]], by="gene", all=T, suffixes=c("",""))
			#df <- full_join(df, d[[i]], by="gene", suffix = c("", ""))
		}
	}
	return(df)
}
if (length(files) > 0) {
	i <- 1
	dat <- list()
	all_genes <- c()
	names <- c("gene", "bootstrap_mean", "check")
	all_colnames <- c("gene", "aligner", "trimmer", "bootstrap_sum", "bootstrap_n", "bootstrap_mean")
	titles <- c()
	plots <- list()
	models <- c()
	thresh <- 0
	genes_above_thresh_outstring <- c()
	for (file in files) {
		# get reusable and meaningful name
		title <- str_split(file, "_")[[1]][3:4]
		# use other stringsplit function which supports fixed=T
		title[2] <- strsplit(title[2], ".", fixed=T)[[1]][1]
		title <- paste(title, collapse="-")
 		names <- c(names,  c("gene", "bootstrap_mean"))
		titles <- c(titles, title)
		dat[[i]] <- read.table(file, sep="\t", header=F)
  		colnames(dat[[i]]) <- all_colnames 
  		#thresh <- dat[[i]]$bootstrap_cutoff[1]
		dat[[i]] <- dat[[i]][,c("gene", "bootstrap_mean")]
		
		#genes_above_thresh_outstring <- c(genes_above_thresh_outstring, paste0("<b>Number of ", title, " trees above bootstrap threshold (",thresh,"): ", nrow(dat[[i]][dat[[i]]$check == "OK", ]), "</b><br>\n"))
		#all_genes <- c(all_genes,dat[[i]]$gene)
		i <- i + 1
	
	}
	data_combined <- do.call(multi_merge, list(dat))

	plot_data <- data_combined[, grepl("bootstrap_mean", names(data_combined))]
	plot_data <- as.data.frame(plot_data) #make sure data structure is dataframe, this is necessary because this will be a vector for a single parameter combination
	colnames(plot_data) <- titles
	p <- plot_ly(type="violin")
	for (j in 1:length(colnames(plot_data))) 
	{
		ngenes <- c()
		for (element in plot_data[,j]) {
			ngenes <- c(ngenes, paste0("<b>Bootstrap cutoff: </b> ", as.character(element), "<br><b>No. of surving genes: </b>", as.character(length(na.omit(plot_data[,j][plot_data[,j] >= element]))))) #determine the number of genes with a certain boostrap of higher
		}
		p <- add_trace(p, x = colnames(plot_data)[j], y=plot_data[,j], name=colnames(plot_data)[j],pointpos=0, hoverinfo="text", hovertext=ngenes, points="all", jitter=0)
	}			
	#p <- p %>% layout(hovermode = "y unified") #unfortunately this does not work together with custom text.
	#print(htmltools::tagList(list(ggplotly(p)))) # this works only when the plot is being shown outside the if statement below! weird!!
	p <- htmltools::tagList(list(ggplotly(p))) # this works only when the plot is being shown outside the if statement below! weird!!
	colnames(data_combined) <- c("gene", titles)		
	cat("<br><b>Overview of mean bootstrap values per gene-tree: </b><br>\n")
	for (j in 1:length(colnames(plot_data)))
	{
		cat(paste0("Total number of gene trees for ", colnames(plot_data)[j],": ", as.character(length(na.omit(plot_data[,j])))))
		cat("<br>\n")
		
	}
	options(knitr.kable.NA = '') # do not display NA values
	#data_combined %>% kbl(escape=F) %>% kable_paper("hover", full_width = F)%>% scroll_box(width = "100%", height = "600px")	
        datatable(data_combined,  escape=FALSE, class = "cell-border stripe", rownames = F, filter="top", editable=TRUE, extensions = c("Buttons","FixedColumns"), options = list(dom="Bfrtip", buttons=list("copy", "csv", "excel", list(extend = "pdf",title = "Gene tree mean bootstrap overview", pageSize = "A4",orientation = "landscape"), "print"), scrollX=T, fixedColumns = list(leftColumns = 1)))

}
if (p != "") {
	p <- p  %>% layout(autosize = F, width = 10, height = 10, showlegend=FALSE) %>% config(displayModeBar=FALSE)# this works only in combination with the print statement above
} else { p <- "gene tree result statistics not found" }
p

```

```{js, echo=FALSE, class.source=".foldable"}
function copytree(id) {
  /* Get the text field */
  var myid = 'myInput' + id
  
  var copyText = document.getElementById(myid);

  /* Select the text field */
  copyText.select();
  copyText.setSelectionRange(0, 99999); /* For mobile devices */

   /* Copy the text inside the text field */
  navigator.clipboard.writeText(copyText.value);

  /* Alert the copied text */
  alert("Tree copied to clipboard.");
}
```

# Maximum-likelihood trees

**Random seed:** `r config_data$seed`

**Location of phylogenetic results:** 
```
results/phylogeny/
```

```{python, echo=FALSE}
mltreestats = []
for bscutoff in all_hashes["mltree"]["mltree"]["per"]:
	for trimmer in all_hashes["mltree"]["mltree"]["per"][bscutoff]["iqtree"]["iqtree"]:
		for aligner in all_hashes["mltree"]["mltree"]["per"][bscutoff]["iqtree"]["iqtree"][trimmer]:
			f = "../results/statistics/mltree/mltree_iqtree_" + aligner + "_" + trimmer + "_" + bscutoff +"_statistics." + all_hashes["mltree"]["mltree"]["per"][bscutoff]["iqtree"]["iqtree"][trimmer][aligner] + ".txt"
			if os.path.exists(f):
				mltreestats.append(f)
	if "raxml" in all_hashes["mltree"]["mltree"]["per"][bscutoff].keys():
		for trimmer in all_hashes["mltree"]["mltree"]["per"][bscutoff]["raxml"]["iqtree"]:
			for aligner in all_hashes["mltree"]["mltree"]["per"][bscutoff]["raxml"]["iqtree"][trimmer]:
				f = "../results/statistics/mltree/mltree_raxml_" + aligner + "_" + trimmer + "_" + bscutoff +"_statistics." + all_hashes["mltree"]["mltree"]["per"][bscutoff]["raxml"]["iqtree"][trimmer][aligner] + ".txt"
				if os.path.exists(f):
					mltreestats.append(f)
```

```{r stats_tree, echo=FALSE, results="asis"}

files <- py$mltreestats
#files <- list.files(path="../results/statistics/mltree/", pattern ="mltree_*", recursive=F)
multi_merge <- function(d) {
	df <- d[[1]]
	if (length(d) >= 2) {
		for (i in 2:length(dat)) {
			df <- merge(df, d[[i]], by="gene", all=T, suffixes=c("",""))
		}
	}
	return(df)
}
if (length(files) > 0) {
	dat <- list()
	i <- 1
	for (file in files) {
		dat[[i]] <- read.table(file, sep=" ", header=F)
		i <- i + 1
	}
	data_combined <- do.call("rbind", dat)
	colnames(data_combined) <- c("software", "aligner", "trimmer", "boostraps", "bootstrap-cutoff", "ngenes", "tree")
	for (i in 1:length(data_combined$tree)) {
	
	data_combined$tree[i] <- paste0('<input type="tree" value="', data_combined$tree[i], '" id="myInput',i,'"><button onclick="copytree(',i,')">Copy tree</button>')	

	}
	cat("<br><b>Overview of concatenated Maximum-likelihood phylogenies:</b>\n")
	data_combined %>% kbl(escape=F) %>% kable_paper("hover", full_width = T) #%>% scroll_box(width = "100%", height = "600px") 
}
```

```{js, echo=FALSE, class.source=".foldable"}
function copyspeciestree(id) {
  /* Get the text field */
  var myid = 'myspeciestree' + id
  
  var copyText = document.getElementById(myid);

  /* Select the text field */
  copyText.select();
  copyText.setSelectionRange(0, 99999); /* For mobile devices */

   /* Copy the text inside the text field */
  navigator.clipboard.writeText(copyText.value);

  /* Alert the copied text */
  alert("Tree copied to clipboard.");
}
```

# Speciestree

```{python, echo=FALSE}
sptreestats = []
for bscutoff in all_hashes["speciestree"]["speciestree"]["per"]:
	for trimmer in all_hashes["speciestree"]["speciestree"]["per"][bscutoff]["astral"]["iqtree"]:
		for aligner in all_hashes["speciestree"]["speciestree"]["per"][bscutoff]["astral"]["iqtree"][trimmer]:
			f = "../results/statistics/speciestree/astral_" + aligner + "-" + trimmer + "-" + bscutoff +"_statistics." + all_hashes["speciestree"]["speciestree"]["per"][bscutoff]["astral"]["iqtree"][trimmer][aligner] + ".txt"
			if os.path.exists(f):
				sptreestats.append(f)
```


**Location of phylogenetic results:** 
```
results/phylogeny/
```

```{r stats_speciestree, echo=FALSE, results="asis"}
files <- py$sptreestats
multi_merge <- function(d) {
	df <- d[[1]]
	if (length(d) >= 2) {
		for (i in 2:length(dat)) {
			df <- merge(df, d[[i]], by="gene", all=T, suffixes=c("",""))
			#df <- full_join(df, d[[i]], by="gene", suffix = c("", ""))
		}
	}
	return(df)
}
if (length(files) > 0) {
	dat <- list()
	i <- 1
	for (file in files) {
		dat[[i]] <- read.table(file, sep=" ", header=F)
		i <- i + 1
	}
	data_combined <- do.call("rbind", dat)
	colnames(data_combined) <- c("software", "aligner", "trimmer", "bootstrap-cutoff", "ngenes", "tree")
	for (i in 1:length(data_combined$tree)) {
	
	data_combined$tree[i] <- paste0('<input type="tree" value="', data_combined$tree[i], '" id="myspeciestree',i,'"><button onclick="copyspeciestree(',i,')">Copy tree</button>')	

	}
	cat("<br><b>Overview of species-tree phylogenies:</b>\n")
	data_combined %>% kbl(escape=F) %>% kable_paper("hover", full_width = T)# %>% scroll_box(width = "100%", height = "600px") 
}
```

# Log

```{r, echo=FALSE}
if (file.exists(runlog_file))
{
  runlog <- read_file(runlog_file)
} else {
  runlog <- "Information not found. Did you run phylociraptor?\n"
}
cat(runlog)
```

