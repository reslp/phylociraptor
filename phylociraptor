#!/usr/bin/env python3

import sys, os, io
sys.path.insert(0, os.getcwd()+"/bin")
from libphylociraptor.usageinfo import *
from libphylociraptor.outfiles import *
from libphylociraptor.hashing import *
from libphylociraptor.check import *
from libphylociraptor.filehandling import *
import subprocess
import argparse
import glob
import logging
import yaml
try:
	import snakemake
except ImportError:
	print("Snakemake was not found. Installation instructions: https://phylociraptor.readthedocs.io/en/latest/introduction/installation.html#create-a-conda-environment-for-snakemake")


if sys.version_info[0] < 3:
	raise Exception("Phylocripator requires Python 3. Will exit.")
	exit(1)
try:
	if snakemake.__version__ != "6.0.2":
		print("WARNING: You are using a different snakemake version (", snakemake.__version__, ") than what is recommended ( 6.0.2 ). This could lead to problems.")
except:
	print("Snakemake version could not be determined which is not a good sign and could lead to problems. It is recommended to install snakemake v6.0.2.")

njobs = "10000"
latency_wait = "10" #in seconds
singularity_bindpoints = "-B $(pwd)/.usr_tmp/:/usertmp"
debug = True #turn debugging mode on (True) and off (False)
cluster_config_defaults= {"slurm": "data/cluster-config-SLURM.yaml.template", "sge":"data/cluster-config-SGE.yaml.template", "torque":"data/cluster-config-TORQUE.yaml.template"}


def progressbar(it, progress, prefix="", size=60, file=sys.stdout):
	count = len(it)
	def show(j):
		x = int(size*j/count)
		return "%s[%s%s] %i/%i\r" % (prefix, "#"*x, "."*(size-x), j, count)
	return show(progress)

def help_message(mes):
	return mes

def determine_submission_mode(flag):
	if "serial" in flag:
		return ["--cores" + flag.replace("serial","")]
	elif "local" in flag:
		return ["--cores" + flag.replace("local", "")]
	elif "sge" in flag: # for SGE the dependencies need to be under quotes, because there are () characters in the dependency string.
		return ["--cluster", "bin/immediate-submit/immediate_submit.py '{dependencies}' %s" % flag, "--immediate-submit", "--jobs", njobs, "--notemp"]
	else:
		return ["--cluster", 'bin/immediate-submit/immediate_submit.py {dependencies} %s' % flag, "--immediate-submit", "--jobs", njobs, "--notemp"]

def get_flags(flags):
	if flags["config_file"]:
		config_data = parse_config_file(flags["config_file"])
	if flags["cluster"] == None and "cluster" not in config_data.keys():
		print(now(), "ERROR: Please provide execution mode either in config file or -t/--cluster")
		sys.exit(1)
	# first check cluster setting
	if "cluster" in config_data.keys() and flags["cluster"] == None: #this assumes a cluster setting is provided in the config file
		if config_data["cluster"] != None and config_data["cluster"] != "": # the provided entry is assumed to be valid
			flags["cluster"] = config_data["cluster"]
		else: # the provided entry is empty => revert to default which is local
			print(now(), "No cluster has been specified in the provided config file. Will revert to default (local).")
			flags["cluster"] = "local"
	if "cluster" not in config_data.keys() and flags["cluster"] == None: # this assumes that nothing was specified (neither in config nor in cli) 
		flags["cluster"] = "local"

	# now check cluster config file
	if "local" not in flags["cluster"] and "serial" not in flags["cluster"]: # this assumes that cluster submission is desired. (no local or serial specified)
		print(now(), "Cluster submission specified (" +flags["cluster"] + ")")
		if flags["cluster_config"] == None: # no cluster-config file specified at CLI
			if "cluster-config" in config_data.keys(): # 1. check if file is provided in config file
				if config_data["cluster-config"] != None and config_data["cluster-config"] != "":
					flags["cluster_config"] = config_data["cluster-config"]
					print(now(), "Using cluster config file: " + flags["cluster_config"])
			else:
				print(now(), "WARNING: No cluster config file specified. Will use default template for cluster type:", cluster_config_defaults[flags["cluster"]])
				flags["cluster_config"] = cluster_config_defaults[flags["cluster"]]
		else:
				print(now(), "Using cluster config file: " + flags["cluster_config"])



					


	else:
		print(now(), "Local job execution specified (" + flags["cluster"] + ")")
	mapdict ={
	"c": "--cluster-config", "cluster_config": "--cluster-config",
	"FORCE": "-F",
	"force": "-f",
	"dry": "-n"
	}
	cmd = []
	if debug:
		print(now(), "DEBUG: flags: ", flags)
	for flag in flags.keys():
		if flag in mapdict.keys() and flags[flag] != None:
			if flag == "t" or flag == "cluster": #handle cluster specification
				arg = mapdict[flag]
				arg = arg + " "+flags[flag]+'"'
				cmd.append(arg) 
			if flag == "c" or flag == "cluster_config": #handle cluster config file
				cmd.append(mapdict[flag])
				cmd.append(flags["cluster_config"])
			else:
				if flags[flag]:
					cmd.append(mapdict[flag])
	cmd += determine_submission_mode(flags["cluster"])
	if debug:
		print(now(), "DEBUG: Flags from get_flags:", cmd)	

	return cmd

def check_required_files(runmode, previous_runmode, args):
	if args.debug:
		print(now(), "DEBUG: Checking required files for:", runmode, "as they should be present")
	hashes = collect_hashes(previous_runmode, parse_config_file(args.config_file), args.config_file, wd=os.getcwd(), debug=args.debug) 
	currenthash = hashes[previous_runmode]["global"]
	for f in outfile_dict[runmode]:
		if currenthash != "":
			f = f.replace("HASH", currenthash)
		if not os.path.isfile(f) and runmode != "mltree":
			print(now(), "ERROR: Some files are missing preventing this part to run.")
			print(now(), "Did you run ", previous_runmode, "which is required by this step?")
			print(now(), "Missing file:", f)
			sys.exit(1)
		elif not os.path.isfile(f) and runmode == "mltree":
			print(now(), "INFO: phylociraptor modeltest was not run, will use specified model for mltree.")
		else:
			if args.debug:
				print(now(), "DEBUG: File found:", f)
	return

#def check_directories(mode, currenthash=""):
#	for directory in outdir_dict[mode]:
#		if currenthash != "":
#			directory = directory.replace("HASH", currenthash[list(currenthash.keys())[0]]["global"])
#		if not os.path.isdir(directory):
#			if debug:
#				print(now(), "DEBUG: check_directories: Directory not found:", directory)
#			return directory
#	return

#def check_hasrun(mode, currenthash=""):
#	f = checkpoint_file_dict[mode]
#	if currenthash != "":
#		f = f.replace("HASH", currenthash[list(currenthash.keys())[0]]["global"])
#	print("hasrun:",f)
#	print("hasrun:",currenthash)
#	if not os.path.isfile(f):
#		if debug:
#			print(now(), "DEBUG: check_hasrun: Not found:", f)
#		return f
#	else:
#		return

def check_config_file(f):
	if os.path.isfile(f):
#		cmd = ['env', 'CONFIG='+f]
#		popen = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		return ["--configfile", f]
	else:
		print(now(), "ERROR: Config file specified with --config-file not found:", f)
		sys.exit(1)

def check_for_errors(result):
	if result.startswith("WorkflowError") or "WorkflowError" in result:
		return now()+" ERROR: phylociraptor encountered an error. Use --debug to diagnose.\n"
	if result.startswith("The singularity command"):
		return result
	if result.startswith("Error") or result.startswith("error"):
		return now()+" ERROR: There was an error. Use --debug to diagnose. The error occurred here: %s " % result	
	if result.startswith("Directory cannot be locked."):
		return now()+" ERROR: "+result	
	if result.startswith("IncompleteFilesException"):
		return now()+" ERROR: There seems to be a problem with incomplete output files from a previous run. You can use --rerun-incomplete to force a rerun of incomplete tasks.\n"
	if result.startswith("KeyError"):
		return now()+" ERROR: "+result
	return ""


def check_required_software():	
	try:
		singularity_version = str(subprocess.check_output(['singularity', 'version']).decode('ascii').strip())
		print(now(), "Singularity version:", singularity_version)
	except FileNotFoundError:
		print(now(), "ERROR: Singularity command not found.")
		sys.exit(1)
	try:
		snakemake_version = str(subprocess.check_output(['snakemake', '-v']).decode('ascii').strip())
		print(now(), "Snakemake version:", snakemake_version)
	except FileNotFoundError:
		print(now(),"ERROR: Snakemake command not found.")
		sys.exit(1)
	
	
def execute_command(cmd, verbose, config, isutil=False):
	# this should also correctly parse and display:
	# IncompleteFilesException
	# when singularity command is not available
	if config:
		cmd = ['CONFIG='+config] + cmd
		cmd = ['env'] + cmd
	popen = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	line = ""
	jobcounts = False
	njobs = 0
	char = ""
	nline = 0
	curr_task = 0
	#verbose = True # there are some problems with the progress bar functionality, until this is fixed verbose is the default.
	if not os.path.isdir("log/phylociraptor"):
		os.mkdir("log/phylociraptor")
	if "-n" in cmd:
		print(now(), "INFO: --dry specified, will only perform a dry run of the analysis")
		for line in io.TextIOWrapper(popen.stdout, encoding="utf-8"):
			nline += 1
			if check_for_errors(line):
				yield check_for_errors(line)
			if debug:
				yield line
			elif verbose:
				if line.startswith("rule") and not debug:
					yield now()+" Task: %s\n" % line.strip().split(" ")[1].rstrip(":")
				if line.lstrip().startswith("wildcards:"):
					yield "\tParameters: %s\n" % line.split(":")[1]
				if line.startswith("Nothing to be done"):
					yield now() + " There is nothing to do. To force a rerun use: -f/--force or -F/--FORCE\n"
			else:
				result = line
				if result.startswith("Nothing"):
					yield now() + " There is nothing to do. To force a rerun use: -f/--force or -F/--FORCE\n"
				if result.startswith("Job counts"):
					jobcounts = True
				elif jobcounts and result != "" and nline <= 30: #only keep jobcount info from the beginning of the output
					if len(result.split("\t")) == 2: # the line with the total number of jobs has two elements
						yield now()+" Total number of tasks for this step: %s\n" % result.split("\t")[1].strip() 
				elif jobcounts and result == "":
					jobcounts = False
				line=""
	elif "--cluster" in cmd:
		if not isutil:
			logging.basicConfig(filename="log/phylociraptor/phylociraptor-log-" + time.strftime("%Y-%m-%d_%H-%M-%S") + ".txt", level=logging.DEBUG,format="%(message)s")	
			logging.debug("PHYLOCIRAPTOR COMMAND: " + " ".join(sys.argv))
			logging.debug("EXECUTED COMMAND: " + " ".join(cmd))
		for line in io.TextIOWrapper(popen.stdout, encoding="utf-8"):
			nline += 1
			logging.debug(line.strip())
			if check_for_errors(line):
				yield check_for_errors(line)
			if debug:
				yield line
			elif verbose:
				if line.startswith("Pulling singularity"):
					container = line.rstrip().split(" ")[-1].strip(".")
					yield now() + " Please be patient as singularity container " + container + " is downloaded. This can take several minutes.\n"
				if line.startswith("rule") and not debug:
					yield now() + " Will submit task: %s\n" % line.strip().split(" ")[1].rstrip(":")
				if line.lstrip().startswith("wildcards:") and not debug:
					yield "\tParameters:" + line.split(":")[1]
				if line.startswith("sbatch") or line.startswith("qsub"):
					yield "\t%s\n" % line
				if line.startswith("Nothing to be done"):
					yield now() + " There is nothing to do. To force a rerun use: -f/--force or -F/--FORCE\n"
			else:
				result = line
				if result.startswith("Singularity"):
					yield result
				if result.startswith("Job counts"):
					jobcounts = True	
				if result.startswith("Pulling singularity"):
					container = result.rstrip().split(" ")[-1].strip(".")
					yield now() + " Please be patient as singularity container " + container + " is downloaded. This can take several minutes.\n"
				elif jobcounts and result != "" and nline <= 30: #only keep jobcount info from the beginning of the output
					if len(result.split("\t")) == 2: # the line with the total number of jobs has two elements
						yield now()+" Total number of jobs to submit: %s\n" % result.split("\t")[1].strip()
						njobs = int(result.split("\t")[1])
				elif jobcounts and result == "":
					jobcounts = False
				if line.startswith("Nothing to be done"):
					yield now() + " There is nothing to do. To force a rerun use: -f/--force or -F/--FORCE\n"
				if line.startswith("rule"):
					curr_task += 1
					yield progressbar(range(njobs),curr_task, "Submitting: ", 100)
				line=""
	else: # serial mode
		if not isutil:
			logging.basicConfig(filename="log/phylociraptor/phylociraptor-log-" + time.strftime("%Y-%m-%d_%H-%M-%S") + ".txt", level=logging.DEBUG,format="%(message)s")	
			logging.debug("PHYLOCIRAPTOR COMMAND: " + " ".join(sys.argv))
			logging.debug("EXECUTED COMMAND: " + " ".join(cmd))
		for line in io.TextIOWrapper(popen.stdout, encoding="utf-8"):
			nline += 1
			logging.debug(line.strip())
			result = line
			if check_for_errors(result):
				yield check_for_errors(result)
			if debug:
				yield line
			elif verbose:
				if line.startswith("Pulling singularity"):
					container = line.rstrip().split(" ")[-1].strip(".")
					yield now() + " Please be patient as singularity container " + container + " is downloaded. This can take several minutes.\n"
				if line.startswith("rule") and not debug:
					yield now()+" Will run task: %s\n" % line.strip().split(" ")[1].rstrip(":")
				if line.lstrip().startswith("wildcards:"):
					yield "\tParameters: %s\n" % line.split(":")[1]
				if line.startswith("Nothing to be done"):
					yield now() + " There is nothing to do. To force a rerun use: -f/--force or -F/--FORCE\n"
				if line.startswith("  |"):
					yield now() + " Progress" + line.strip("\n") + "\r"
			else: # this is the quiet mode with progressbar
				#if check_for_errors(result):
				#	yield check_for_errors(result)
				if result.startswith("Job counts"):
					jobcounts = True	
				if result.startswith("Pulling singularity"):
					container = result.rstrip().split(" ")[-1].strip(".")
					yield now() + " Please be patient as singularity container " + container + " is downloaded. This can take several minutes.\n"
				elif jobcounts and result != "" and nline <= 30: #only keep jobcount info from the beginning of the output, typically 30 lines will be enough
					if len(result.split("\t")) == 2: # the line with the total number of jobs has two elements
						yield now()+" Total number of tasks to run: %s\n" % result.split("\t")[1].strip()
						njobs = int(result.split("\t")[1])
				elif jobcounts and result == "":
					jobcounts = False
				if line.startswith("rule"):
					curr_task += 1
					yield progressbar(range(njobs),curr_task, "Runnning: ", 100)
				if line.startswith("Nothing to be done"):
					yield now() + " There is nothing to do. To force a rerun use: -f/--force or -F/--FORCE\n"
				if line.startswith("  |"):
					yield now() + " Progress" + line.strip("\n") + "\r"
				line=""

def get_additional_snakemake_flags(flags, rerun, unlock):
	if flags:
		flags= flags.strip() #need to remove trailing charcters such as spaces first otherwise the list will be messed up
	if rerun: # add --rerun-incomplete in case it is set
		if flags: #add depending on if flags already contains values or not
			flags += " --rerun-incomplete"
		else:
			flags += "--rerun-incomplete"
	if unlock:
		if flags:
			flags += " --unlock"
		else:
			flags += "--unlock"
	if debug:
		if flags:
			flags += " -p"
		else:
			flags += "-p"
	if flags:
		if debug:
			print(now(), "DEBUG: Additional flags will be passed on to snakemake: ", flags)
		return flags.split(" ")
	else:
		return []

def get_additional_singularity_flags(flags):
	if flags:
		if debug:
			print(now(), "DEBUG: Additional flags will be passed on to singularity: ", flags)
		return ["--singularity-args"]+[singularity_bindpoints +" " + flags]
	else:
		return ["--singularity-args"]+ [singularity_bindpoints]

def get_container(container):
	containerfile = "data/containers.yaml"
	if not os.path.isfile(containerfile):
		print(now(), "The containers file is missing:", containerfile)
		print(now(), "Unable to continue.")
		sys.exit(1)
	with open(containerfile) as f:
		data = yaml.load(f, Loader=yaml.FullLoader)
		if container in data.keys():
			return data[container]
		else:
			print(now(), "Container", container, "not found in containersfile:", containerfile)
			print(now(), "Unable to continue with requested command.")
			sys.exit(1)
		

def check_help_and_config(params, helpmsg):
	if params.help: # help is specified
		print(help_message(helpmsg))
		sys.exit(0)
	if params.config_file == "data/config.yaml":
		print(now(), "No config file specified, will use default:", params.config_file)
	else:
		print(now(), "Will use the specified config file:", params.config_file)


	
pars = argparse.ArgumentParser(usage=help_message(default_help))
pars.add_argument('-v', '--version', action='store_true', dest='version', required=False)
pars.add_argument('command', action='store', nargs="?")
pars.add_argument('arguments', action='store', nargs=argparse.REMAINDER)

args = pars.parse_args()

def get_commit():
		return str(subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).decode('ascii').strip())

if args.version == True:
	commit = get_commit()
	print("Version:", version)
	print("Git commit:", commit)
	sys.exit(0)


if not args.command:
	print(default_help)
	sys.exit(0)

# create own argparse class to include some standard options:
class PhyloParser(argparse.ArgumentParser):
	def __init__(self, **kwargs):
		super().__init__(**kwargs)
		self.add_argument("-f", "--force", action="store_true" )
		self.add_argument("-F", "--FORCE", action="store_true" )
		self.add_argument("-t", "--cluster",  action="store", default=None)
		self.add_argument("-c", "--cluster-config", action="store", default=None)
		self.add_argument("--dry", action="store_true")
		self.add_argument("-h", "--help", action="store_true")
		self.add_argument("--verbose", action="store_true", default=False)	
		self.add_argument("--singularity", action="store",dest="si_args", default="")
		self.add_argument("--snakemake", action="store",dest="sm_args", default="")
		self.add_argument("--rerun-incomplete", action="store_true", dest="rerun", default=False)
		self.add_argument("--unlock", action="store_true", dest="unlock", default=False)
		self.add_argument('--debug', action='store_true', dest="debug", required=False)

def check_debug(debug):
	if debug:
		#print(now(), "DEBUG: Addditional debugging output enabled.")
		return True
	else:
		return False

class UtilParser(argparse.ArgumentParser):
	def __init__(self, **kwargs):
		super().__init__(**kwargs)
		self.add_argument("-h", "--help", action="store_true")
		self.add_argument("--verbose", action="store_true", default=False)	
		self.add_argument('--debug', action='store_true', dest="debug", required=False)
	

if args.command == "setup":
	print(now(), "Welcome to phylociraptor setup v%s" % version)
	setup_parser = PhyloParser(usage=help_message(setup_help), add_help=False)
	setup_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	setup_parser.add_argument("--samples-csv", action="store", dest="samples_file")
	setup_parser.add_argument("--busco-set", action="store", dest="busco_set")
	setup_parser.add_argument("--add_genomes", action="store_true",default=False, dest="add_genomes")

	setup_args = setup_parser.parse_args(args.arguments)
	debug = check_debug(setup_args.debug) #check if debug is enabled
	check_help_and_config(setup_args, setup_help) 	
	
	check_required_software()
	
	if (setup_args.add_genomes):
		print(now(),"Will only add genomes")
		cmd = ["snakemake","-p", "-s" , "rules/setup.smk", "--use-singularity", "-r", "add_genomes", "--latency-wait", latency_wait]
	else:
		cmd = ["snakemake","-p", "-s" , "rules/setup.smk", "--use-singularity", "-r", "setup", "--latency-wait", latency_wait]
	cmd += get_flags(vars(setup_args))

	# check for overrides of config file parameters	
	if setup_args.config_file:
		cmd += check_config_file(setup_args.config_file)
	if setup_args.busco_set or setup_args.samples_file:
		cmd += ["--config"]
		if not os.path.isfile(setup_args.samples_file):
			print(now(), "ERROR: File specified with --samples-csv not found:", setup_args.samples_file)
			sys.exit(0)
		cmd += ["busco={set: %s}" % setup_args.busco_set]
		cmd += ["species='%s'" % setup_args.samples_file]
	
	cmd += get_additional_snakemake_flags(setup_args.sm_args, setup_args.rerun, setup_args.unlock)
	cmd += get_additional_singularity_flags(setup_args.si_args)

	for line in execute_command(cmd, setup_args.verbose, config=setup_args.config_file):
		print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))

elif args.command=="orthology":
	print(now(), "Welcome to phylociraptor orthology v%s" % version)
	orthology_parser = PhyloParser(usage=help_message(orthology_help),add_help=False)	
	orthology_parser.add_argument("--busco_threads", action="store")
	orthology_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	orthology_parser.add_argument("--augustus_species", action="store")
	orthology_parser.add_argument("--additional_params", action="store")
	orthology_args = orthology_parser.parse_args(args.arguments)
	debug = check_debug(orthology_args.debug) #check if debug is enabled
	check_help_and_config(orthology_args, orthology_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], orthology_args)
	cmd = ["snakemake","-p", "-s", "rules/orthology.smk", "--use-singularity", "-r", "orthology", "--latency-wait", latency_wait]
	cmd += get_flags(vars(orthology_args))

	# check for overrides of config file parameters	
	if orthology_args.config_file:
		cmd += check_config_file(orthology_args.config_file)
	if orthology_args.busco_threads or orthology_args.augustus_species or orthology_args.additional_params:
		cmd += ["--config"]
		arg = "busco={"
		if orthology_args.busco_threads: #evaluation of this string by snakemake is lazy, it does not seem to matter if there are extra , characters...
			arg += "threads: %s, " % orthology_args.busco_threads
		if orthology_args.augustus_species:
			arg += "augustus_species: %s, " % orthology_args.augustus_species
		if orthology_args.additional_params:
			arg += "additional_parameters: %s " % orthology_args.additional_params
		arg+="}"
		cmd += [arg]
	
	cmd += get_additional_snakemake_flags(orthology_args.sm_args, orthology_args.rerun, orthology_args.unlock)
	cmd += get_additional_singularity_flags(orthology_args.si_args)

	
	for line in execute_command(cmd, orthology_args.verbose, config=orthology_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))
elif args.command=="filter-orthology":
	print(now(), "Welcome to phylociraptor filter-orthology v%s" % version)
	forthology_parser = PhyloParser(add_help=False)
	forthology_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	forthology_parser.add_argument("--dupseq", action="store")
	forthology_parser.add_argument("--cutoff", action="store")
	forthology_parser.add_argument("--minsp", action="store")
	forthology_parser.add_argument("--seqtype", action="store")
	
	forthology_args = forthology_parser.parse_args(args.arguments)	
	debug = check_debug(forthology_args.debug) #check if debug is enabled
	check_help_and_config(forthology_args, forthology_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], forthology_args)
	
	cmd = ["snakemake", "-p", "-s", "rules/filter-orthology.smk", "--use-singularity", "-r", "filter_orthology", "--latency-wait", latency_wait]
	cmd += get_flags(vars(forthology_args))
	
	# check for overrides of config file parameters	
	if forthology_args.config_file:
		cmd += check_config_file(forthology_args.config_file)
	if forthology_args.dupseq or forthology_args.cutoff or forthology_args.minsp or forthology_args.seqtype:
		cmd += ["--config"]
		arg = "filtering={"
		if forthology_args.dupseq:
			if forthology_args.dupseq in ["persample", "perfile"]:
				arg += "dupseq: %s, "% forthology_args.dupseq
			else:
				print(now(), "ERROR: Wrong parameter specified for --dupseq: ", forthology_args.dupseq)
				sys.exit(0)
		if forthology_args.cutoff:
			if float(forthology_args.cutoff) >=0 and float(forthology_args.cutoff) <=1:
				arg += "cutoff: %s, " % forthology_args.cutoff
			else:
				print(now(), "ERROR: Wrong parameter specified for --cutoff: ", forthology_args.dubseq)	
				sys.exit(0)
		if forthology_args.minsp:
			arg += "minsp: %s, " %forthology_args.minsp
		if forthology_args.seqtype:
			if forthology_args.seqtype in ["aa", "nu"]:
				arg += "seq_type: %s " % forthology_args.seqtype
			else:
				print(now(), "ERROR: Wrong parameter specified for --seqtype: ", forthology_args.seqtype)
				sys.exit(0)
		arg += "}"
		cmd += [arg]
	
	cmd += get_additional_snakemake_flags(forthology_args.sm_args, forthology_args.rerun, forthology_args.unlock)
	cmd += get_additional_singularity_flags(forthology_args.si_args)
	
	for line in execute_command(cmd, forthology_args.verbose, config=forthology_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))
elif args.command=="align":
	print(now(), "Welcome to phylociraptor align v%s" % version)
	align_parser = PhyloParser(usage=help_message(align_help), add_help=False)
	align_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	align_parser.add_argument("--method", action="store")
	align_parser.add_argument("--threads", action="store")
	align_parser.add_argument("--parameters", action="store")
	align_args = align_parser.parse_args(args.arguments)	
	debug = check_debug(align_args.debug) #check if debug is enabled
	check_help_and_config(align_args, align_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], align_args)

	cmd = ["snakemake", "-p", "-s", "rules/align.smk", "--use-singularity", "-r", "align", "--latency-wait", latency_wait]
	cmd += get_flags(vars(align_args))

	# check for overrides of config file parameters	
	if align_args.config_file:
		cmd += check_config_file(align_args.config_file)
	if align_args.method or align_args.threads or align_args.parameters:
		cmd += ["--config"]
		arg = "alignment={"
		if align_args.method:
			if align_args.method in ["mafft"]:
				arg += "method: %s, " % align_args.method
			else:
				print(now(), "ERROR: Wrong parameter specified with --method:", align_args.method)
				sys.exit(0)	
		if align_args.threads:
			arg += "threads: %s, " % align_args.threads
		if align_args.parameters:
			arg += "parameters: '%s'" % align_args.parameters
		arg += " }"
		cmd += [arg]	
	
	cmd += get_additional_snakemake_flags(align_args.sm_args, align_args.rerun, align_args.unlock)
	cmd += get_additional_singularity_flags(align_args.si_args)
	
	for line in execute_command(cmd, align_args.verbose, config=align_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))
elif args.command=="filter-align":
	print(now(), "Welcome to phylociraptor filter-align v%s" % version )
	falign_parser = PhyloParser(usage=help_message(falign_help), add_help=False)
	falign_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	falign_parser.add_argument("--method", action="store")
	falign_parser.add_argument("--parameters", action="store")
	falign_parser.add_argument("--min_parsimony_sites", action="store")
	
	falign_args = falign_parser.parse_args(args.arguments)	
	debug = check_debug(falign_args.debug) #check if debug is enabled
	check_help_and_config(falign_args, falign_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], falign_args)

	cmd = ["snakemake","-p", "-s", "rules/filter-align.smk", "--use-singularity", "-r", "filter_align", "--latency-wait", latency_wait]
	cmd += get_flags(vars(falign_args))
	
	# check for overrides of config file parameters	
	if falign_args.config_file:
		cmd += check_config_file(falign_args.config_file)
	if falign_args.method or falign_args.min_parsimony_sites or falign_args.parameters:
		cmd += ["--config"]
		arg = "trimming={" 
		if falign_args.min_parsimony_sites:
			arg += "min_parsimony_sites: %s, " % falign_args.min_parsimony_sites
		if falign_args.method:
			arg += "method: %s, " % falign_args.method
		if falign_args.parameters:
			arg += "parameters: %s " % falign_args.parameters
		arg += "}"
		cmd += [arg]

	cmd += get_additional_snakemake_flags(falign_args.sm_args, falign_args.rerun, falign_args.unlock)
	cmd += get_additional_singularity_flags(falign_args.si_args)

	for line in execute_command(cmd, falign_args.verbose, config=falign_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))
elif args.command=="speciestree":
	print(now(), "Welcome to phylociraptor speciestree v%s" % version)
	sptree_parser = PhyloParser(add_help=False)
	sptree_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	sptree_args = sptree_parser.parse_args(args.arguments)	
	debug = check_debug(sptree_args.debug) #check if debug is enabled
	
	check_help_and_config(sptree_args, sptree_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], sptree_args)

	cmd = ["snakemake", "-p","-s", "rules/speciestree.smk", "--use-singularity", "-r", "speciestree", "--latency-wait", latency_wait]
	cmd += get_flags(vars(sptree_args))
	
	# check for overrides of config file parameters	
	if sptree_args.config_file:
		cmd += check_config_file(sptree_args.config_file)
	
	cmd += get_additional_snakemake_flags(sptree_args.sm_args, sptree_args.rerun, sptree_args.unlock)
	cmd += get_additional_singularity_flags(sptree_args.si_args)
	
	for line in execute_command(cmd, sptree_args.verbose, config=sptree_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))
elif args.command=="njtree":
	print(now(), "Welcome to phylociraptor njtree %s" % version)
	njtree_parser = PhyloParser(add_help=False)
	njtree_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	njtree_args = njtree_parser.parse_args(args.arguments)	
	debug = check_debug(njtree_args.debug) #check if debug is enabled

	check_help_and_config(njtree_args, njtree_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], njtree_args)

	cmd = ["snakemake", "-s", "rules/njtree.smk", "--use-singularity", "-r", "njtree", "--latency-wait", latency_wait]
	cmd += get_flags(vars(njtree_args))
	
	# check for overrides of config file parameters	
	if njtree_args.config_file:
		cmd += check_config_file(njtree_args.config_file)
	
	cmd += get_additional_snakemake_flags(njtree_args.sm_args, njtree_args.rerun, njtree_args.unlock)
	cmd += get_additional_singularity_flags(njtree_args.si_args)
	
	for line in execute_command(cmd, njtree_args.verbose, njtree_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))
elif args.command=="mltree":
	print(now(), "Welcome to phylociraptor mltree v%s" % version)
	tree_parser = PhyloParser(add_help=False)
	tree_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	tree_args = tree_parser.parse_args(args.arguments)	
	debug = check_debug(tree_args.debug) #check if debug is enabled
	check_help_and_config(tree_args, tree_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], tree_args)

	cmd = ["snakemake", "-s", "rules/mltree.smk", "--use-singularity", "-r", "mltree", "--latency-wait", latency_wait]
	cmd += get_flags(vars(tree_args))
	
	# check for overrides of config file parameters	
	if tree_args.config_file:
		cmd += check_config_file(tree_args.config_file)
	
	cmd += get_additional_snakemake_flags(tree_args.sm_args, tree_args.rerun, tree_args.unlock)
	cmd += get_additional_singularity_flags(tree_args.si_args)
	
	
	for line in execute_command(cmd, tree_args.verbose, config=tree_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))
elif args.command=="bitree":
	print(now(), "Welcome to phylociraptor bitree v%s" % version)
	tree_parser = PhyloParser(add_help=False)
	tree_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	tree_args = tree_parser.parse_args(args.arguments)	
	debug = check_debug(tree_args.debug) #check if debug is enabled
	check_help_and_config(tree_args, bitree_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], tree_args)

	cmd = ["snakemake", "-s", "rules/bitree.smk", "--use-singularity", "-r", "bitree", "--latency-wait", latency_wait]
	cmd += get_flags(vars(tree_args))
	
	# check for overrides of config file parameters	
	if tree_args.config_file:
		cmd += check_config_file(tree_args.config_file)
	
	cmd += get_additional_snakemake_flags(tree_args.sm_args, tree_args.rerun, tree_args.unlock)
	cmd += get_additional_singularity_flags(tree_args.si_args)
	
	
	for line in execute_command(cmd, tree_args.verbose, config=tree_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))
elif args.command=="modeltest":
	print(now(), "Welcome to phylociraptor modeltest v%s" % version)
	model_parser = PhyloParser(add_help=False)
	model_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	model_args = model_parser.parse_args(args.arguments)	
	debug = check_debug(model_args.debug) #check if debug is enabled
	check_help_and_config(model_args, model_help) 	
	check_required_software()
	check_required_files(args.command, previous_steps[args.command], model_args)

	cmd = ["snakemake", "-p", "-s", "rules/modeltest.smk", "--use-singularity", "-r", "modeltest", "--latency-wait", latency_wait]
	cmd += get_flags(vars(model_args))
	
	# check for overrides of config file parameters	
	if model_args.config_file:
		cmd += check_config_file(model_args.config_file)
	
	cmd += get_additional_snakemake_flags(model_args.sm_args, model_args.rerun, model_args.unlock)
	cmd += get_additional_singularity_flags(model_args.si_args)

	for line in execute_command(cmd, model_args.verbose, config=model_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(),"DEBUG:", " ".join(cmd))	
elif args.command=="report":
	print(now(), "Welcome to phylociraptor report v%s" % version)
	report_parser = argparse.ArgumentParser(add_help=False)
	report_parser.add_argument("-h", "--help", action="store_true")
	report_parser.add_argument("--verbose", action="store_true", default=False)
	report_parser.add_argument("--figure", action="store_true", default=False)
	report_parser.add_argument("--seperate", action="store_true", default=False)
	report_parser.add_argument("--debug", action="store_true", default=False)
	report_parser.add_argument("--config-file", action="store", dest="config_file", default="data/config.yaml")
	report_args = report_parser.parse_args(args.arguments)
	debug = check_debug(report_args.debug) #check if debug is enabled
	print(now(), "Will create a phylociraptor report...")
	
	if report_args.help: # help is specified
		print(help_message(report_help))
		sys.exit(0)
	check_required_software()

	#if check_required_files(args.command):
	#	print(now(), "ERROR: Some files are missing preventing this part to run.\nDid your run the required steps before? Missing file:", check_required_files(args.command))
	#	sys.exit(0)

	if report_args.figure:
		cmd = ["singularity", "exec", "-B", os.getcwd(), "docker://reslp/rmarkdown:4.0.3", "Rscript", "./bin/report_figure.R"]
		if report_args.config_file:
			cmd += [report_args.config_file]
		if report_args.seperate:
			cmd += ["yes"]
		else:
			cmd += ["no"]
	else:
		rcommand = """ rmarkdown::render('./bin/report.Rmd') """
		cmd = ["singularity", "exec", "-B", os.getcwd(), "docker://reslp/rmarkdown:4.0.3","Rscript", "-e", rcommand, os.getcwd()]
		if report_args.config_file:
			cmd += [report_args.config_file]
	#proc = subprocess.run(cmd)
	for line in execute_command(cmd, report_args.verbose, config=report_args.config_file):
                print(line, end="\r")
	if debug:
		print(now(), "DEBUG:", " ".join(cmd))

	if os.path.isfile("bin/report.html") and report_args.figure == False:
		subprocess.call(["mv", "bin/report.html", "results/report.html"])
		print(now(), "Your phylociraptor report has been created in the results folder: results/report.html")
	elif os.path.isfile("bin/report-figure.pdf"):
		subprocess.call(["mv", "bin/report-figure.pdf", "results/report-figure.pdf"])
		print(now(), "Your phylociraptor report figure has been created in the results folder: results/report-figure.pdf")
	else:
		print(now(), "Report not found. Maybe something did go wrong?")

elif args.command == "check":
	print(now(), "Welcome to phylociraptor check v%s" % version)
	check_parser = argparse.ArgumentParser(add_help=False)
	check_parser.add_argument("-h", "--help", action="store_true")
	check_parser.add_argument("--config-file", dest="configfile", action="store", default="data/config.yaml")
	check_parser.add_argument("--verbose", action="store_true", default=False)
	check_parser.add_argument("--debug", action="store_true", dest="debug", default=False)
	check_args = check_parser.parse_args(args.arguments)
	debug = check_debug(check_args.debug) #check if debug is enabled
		
	if check_args.help: 
		print(help_message(check_help))
		sys.exit(0)

	print(now(), "Will check the status of the pipeline:")
	if os.path.exists(check_args.configfile):
		print(now(), "A configfile was provided. Will only look for analyses matching:", check_args.configfile)
	else:
		print(now(), "The provided configfile", check_args.configfile, "could not be found. Please check.")
		sys.exit(1)
	check_rest = True
	filter_align_done = False
	currenthash = ""
	all_hashes = {}
	if check_args.configfile:
		print(now(), "Will now calculate analysis hashes, this may take a few seconds...")
		for mode in steps_to_check:
			all_hashes[mode] = collect_hashes(mode, parse_config_file(check_args.configfile), check_args.configfile, debug=check_args.debug, wd=os.getcwd())

	step_status = {"setup": 0, "orthology": 0, "filter-orthology": 0, "align": 0, "filter-align": 0, "modeltest": 0, "njtree": 0, "mltree": 0, "speciestree": 0}									
	for mode in steps_to_check:
		print("\n phylociraptor", mode, end = "")
		if has_outfile(mode=mode, previous_mode=previous_steps[mode], hashes = all_hashes[mode], previous_hashes=all_hashes[previous_steps[mode]], debug=check_args.debug, verbose=check_args.verbose):
			print(" ...", '\033[92m', "DONE", '\033[0m')
			print("  Results:")
			print(return_results_location(mode=mode, hashes=all_hashes[mode], debug=check_args.debug, verbose=check_args.verbose))
			step_status[mode] = 1
		else:
			if step_status[previous_steps[mode]] == 1:
				check_is_running(mode=mode, previous_mode=previous_steps[mode], hashes=all_hashes[mode], previous_hashes=all_hashes[previous_steps[mode]], debug=check_args.debug, verbose=check_args.verbose)		
				print(" ", mode, " ...", '\033[91m' , "INCOMPLETE / RUNNING", '\033[0m')
			else:
				print(" ", mode, " ...", '\033[93m', "NOT EVALUATED", '\033[0m', "(preceeding step [" + previous_steps[mode] + "] not finished)")	
	print("\n"+now(), "phylociraptor check is done.\n")

elif args.command == "util":
	print(now(), "Welcome to phylociraptor util v%s" % version)
	if  len(args.arguments) == 0: 
		print(help_message(util_help))
		sys.exit(0)
	elif args.arguments[0] == "-h" or args.arguments[0] == "--help":
		print(help_message(util_help))
		sys.exit(0)
	else:
		which_util = args.arguments.pop(0)
	debug = check_debug(True) #for util debugging output is enabled by default
	if which_util == "get-lineage":
		gl_parser = UtilParser(add_help=False)
		gl_parser.add_argument("-d","--datafile", action="store", default="data/data.csv")
		gl_parser.add_argument("-o", "--outfile", action="store") 
		gl_parser.add_argument("--quiet", action="store_true", default=False) 
		gl_parser.add_argument("--force", action="store_true", default=False)
		gl_args = gl_parser.parse_args(args.arguments) 
		if gl_args.help: 
			print(help_message(util_lineage_help))
			sys.exit(0)
		if not gl_args.outfile or not gl_args.datafile:
			print(help_message(util_lineage_help))
			sys.exit(0)
		if not os.path.isfile(gl_args.datafile):
			print(now(), "Genome file not found:",gl_args.datafile)
			sys.exit(1)
		if gl_args.force:
			print(now(), "Will download lineage data:")
			keep = "force"
		else:
			if os.path.exists("data/lineage_information/lineage_information.csv"):
				print(now(), "The file: data/lineage_information/lineage_information.csv already exists")
				print(now(), " => SKIPPING DOWNLOAD. You may use --force to redownload")
				keep = "keep"
			else:
				keep = "force"
		
		cmd = ["singularity", "exec", "-B", os.getcwd(), "docker://reslp/taxonkit:0.12.0", "bash", "bin/get_lineage.sh", gl_args.datafile, keep]
		if debug:
			print(cmd)
		for line in execute_command(cmd, not gl_args.quiet, None):
			print(line, end="\r")
		print(now(), "Will now reformat lineage information for downstream applications like phylociraptor util plot-tree")
		cmd = ["singularity", "exec", "-B", os.getcwd(), "docker://reslp/biopython_plus:1.77", "python", "bin/reformat_lineage.py", "data/lineage_information/lineage_information.csv", gl_args.outfile]
		if debug and gl_args.verbose:
			print(cmd)
		for line in execute_command(cmd, not gl_args.quiet, config=None):
			print(line, end="\r")
	if which_util == "estimate-conflict":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-i","--intrees", action="store", default="all")
		qs_parser.add_argument("-o", "--outfile", action="store") 
		qs_parser.add_argument("-s", "--seed", action="store", default="random") 
		qs_parser.add_argument("-n", "--nquartets", action="store", default=None)
		qs_parser.add_argument("-t", "--threads", action="store", default="1")
		qs_parser.add_argument("-l", "--lineagefile", action="store")
		qs_parser.add_argument("-b", "--stopby", action="store", default=None)
		qs_parser.add_argument("-a", "--selecttaxa", action="store", default="")
		qs_parser.add_argument("--config-file", dest="configfile", action="store", default="data/config.yaml")
		qs_parser.add_argument("--quiet", action="store_true", default=False) 
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help: 
			print(help_message(util_estimate_conflict_help))
			sys.exit(0)
		if not qs_args.outfile:
			print(now(),"You need to specify an output file with -o/--outfile")
			print(help_message(util_estimate_conflict_help))
			sys.exit(1)
		if not qs_args.intrees:
			print(now(),"No input trees specified with -i/--intrees")
			print(help_message(util_estimate_conflict_help))
			sys.exit(1)
		elif qs_args.intrees == "all":
			print(now(), "Will compare all trees, this expects phylociraptor mltree and/or speciestree to be finished.")
			print(now(), "Calculating analysis hashes for mltree, this may take a few seconds...")
			hashes = {}
			hashes["mltree"] = collect_hashes("mltree", parse_config_file(qs_args.configfile), qs_args.configfile, debug=qs_args.debug, wd=os.getcwd())
			print(now(), "Calculating analysis hashes for speciestree, this may take a few seconds...")
			hashes["speciestree"] = collect_hashes("speciestree", parse_config_file(qs_args.configfile), qs_args.configfile, debug=qs_args.debug, wd=os.getcwd())	
			combinations = []
			#first calculate all possible combinations:
			for bs in hashes["mltree"]["mltree"]["per"]:
				for treeprog in hashes["mltree"]["mltree"]["per"][bs]:
					for trimmer in hashes["mltree"]["mltree"]["per"][bs][treeprog]["iqtree"]:
						for aligner in hashes["mltree"]["mltree"]["per"][bs][treeprog]["iqtree"][trimmer]:
							if treeprog == "iqtree":
								filename = "concat.contree"
							elif treeprog == "raxml":
								filename = "raxmlng.raxml.support"
							combinations.append("results/phylogeny/" + treeprog + "/bootstrap-cutoff-" + bs + "/" + aligner + "-" + trimmer + "." + hashes["mltree"]["mltree"]["per"][bs][treeprog]["iqtree"][trimmer][aligner] + "/" + filename)
			for bs in hashes["speciestree"]["speciestree"]["per"]:
				for treeprog in hashes["speciestree"]["speciestree"]["per"][bs]:
					for trimmer in hashes["speciestree"]["speciestree"]["per"][bs][treeprog]["iqtree"]:
						for aligner in hashes["speciestree"]["speciestree"]["per"][bs][treeprog]["iqtree"][trimmer]:
							combinations.append("results/phylogeny/" + treeprog + "/bootstrap-cutoff-" + bs + "/" + aligner + "-" + trimmer + "." + hashes["speciestree"]["speciestree"]["per"][bs][treeprog]["iqtree"][trimmer][aligner] + "/species_tree.tre")
			## TODO: Add logic for bitrees here to get all combinations!!
			# now check which files are there in the file system:
			iqtree_trees = glob.glob("results/phylogeny/iqtree/bootstrap-cutoff-*/*/concat.contree")
			raxml_trees =  glob.glob("results/phylogeny/raxml/bootstrap-cutoff-*/*/raxmlng.raxml.support")
			astral_trees = glob.glob("results/phylogeny/astral/bootstrap-cutoff-*/*/species_tree.tre")
			bi_trees = glob.glob("results/phylogeny/phylobayes/bootstrap-cutoff-*/*/phylobayes.con.tre")
			all_trees = iqtree_trees + raxml_trees + astral_trees + bi_trees
			all_trees = [tree for tree in all_trees if tree in combinations] #keep only files which are specified in config file.
			all_trees = ",".join(all_trees)
		else:
			all_trees = qs_args.intrees	
		cmd = ["singularity", "exec", "-B", os.getcwd(), "docker://reslp/phylopy:2", "python", "bin/estimate_conflict.py", "-i", all_trees,  "-o", qs_args.outfile, "-s", qs_args.seed, "-t", qs_args.threads]

		if qs_args.lineagefile and qs_args.selecttaxa:
			cmd += ["-l", qs_args.lineagefile, "--selecttaxa", qs_args.selecttaxa]
		elif not qs_args.lineagefile and "tips" not in qs_args.selecttaxa:
			cmd += ["--selecttaxa", qs_args.selecttaxa]
		if qs_args.nquartets:
			cmd += ["-q", qs_args.nquartets]
		elif qs_args.stopby:
			cmd += ["-b", qs_args.stopby]
		else:
			print(now(), "You need to either specify a stopping criterion (-b) or the total number of quartets (-n).")
			sys.exit(1)
			

		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, not qs_args.quiet, config=None):
			print(line, end="\r")
	if which_util == "plot-tree":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-i","--intrees", action="store")
		qs_parser.add_argument("-o", "--outprefix", action="store", default="tree-plot") 
		qs_parser.add_argument("-g", "--outgroup", action="store", default="none")
		qs_parser.add_argument("-l", "--lineagefile", action="store", default="none")
		qs_parser.add_argument("-e", "--level", action="store", default="none")
		qs_parser.add_argument("-s", "--seed", action="store", default="random") 
		qs_parser.add_argument("--config-file", dest="configfile", action="store", default="data/config.yaml")
		qs_parser.add_argument("--quiet", action="store_true", default=False) 
		qs_parser.add_argument("--single", action="store_true", default=False)
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help: 
			print(help_message(util_plot_tree_help))
			sys.exit(0)
		if not qs_args.intrees:
			print(now(),"Hint: No input trees specified with -i/--intrees")
			print(help_message(util_plot_tree_help))
			sys.exit(1)
		elif qs_args.intrees == "all":
			print(now(), "Will compare all trees, this expects phylociraptor mltree and/or speciestree to be finished.")
			print(now(), "Calculating analysis hashes for mltree, this may take a few seconds...")
			hashes = {}
			hashes["mltree"] = collect_hashes("mltree", parse_config_file(qs_args.configfile), qs_args.configfile, debug=qs_args.debug, wd=os.getcwd())
			print(now(), "Calculating analysis hashes for speciestree, this may take a few seconds...")
			hashes["speciestree"] = collect_hashes("speciestree", parse_config_file(qs_args.configfile), qs_args.configfile, debug=qs_args.debug, wd=os.getcwd())	
			combinations = []
			#first calculate all possible combinations:
			for bs in hashes["mltree"]["mltree"]["per"]:
				for treeprog in hashes["mltree"]["mltree"]["per"][bs]:
					for trimmer in hashes["mltree"]["mltree"]["per"][bs][treeprog]["iqtree"]:
						for aligner in hashes["mltree"]["mltree"]["per"][bs][treeprog]["iqtree"][trimmer]:
							if treeprog == "iqtree":
								filename = "concat.contree"
							elif treeprog == "raxml":
								filename = "raxmlng.raxml.support"
							combinations.append("results/phylogeny/" + treeprog + "/bootstrap-cutoff-" + bs + "/" + aligner + "-" + trimmer + "." + hashes["mltree"]["mltree"]["per"][bs][treeprog]["iqtree"][trimmer][aligner] + "/" + filename)
			for bs in hashes["speciestree"]["speciestree"]["per"]:
				for treeprog in hashes["speciestree"]["speciestree"]["per"][bs]:
					for trimmer in hashes["speciestree"]["speciestree"]["per"][bs][treeprog]["iqtree"]:
						for aligner in hashes["speciestree"]["speciestree"]["per"][bs][treeprog]["iqtree"][trimmer]:
							combinations.append("results/phylogeny/" + treeprog + "/bootstrap-cutoff-" + bs + "/" + aligner + "-" + trimmer + "." + hashes["speciestree"]["speciestree"]["per"][bs][treeprog]["iqtree"][trimmer][aligner] + "/species_tree.tre")
			# now check which files are there in the file system:
			iqtree_trees = glob.glob("results/phylogeny/iqtree/bootstrap-cutoff-*/*/concat.contree")
			raxml_trees =  glob.glob("results/phylogeny/raxml/bootstrap-cutoff-*/*/raxmlng.raxml.support")
			astral_trees = glob.glob("results/phylogeny/astral/bootstrap-cutoff-*/*/species_tree.tre")
			all_trees = iqtree_trees + raxml_trees + astral_trees
			all_trees = [tree for tree in all_trees if tree in combinations] #keep only files which are specified in config file.	
			all_trees = ",".join(all_trees)
		else:
			all_trees = qs_args.intrees	
		if qs_args.single:
			single = "yes"
		else:
			single = "no"

		cmd = ["singularity", "exec", "-B", os.getcwd(), get_container("rphylo"), "Rscript", "bin/plot-tree.R"]
		cmd += [os.getcwd(), qs_args.seed, all_trees, qs_args.outgroup, qs_args.lineagefile, qs_args.level, qs_args.outprefix, single]

		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, not qs_args.quiet, config=None):
			print(line, end="\r")
	if which_util == "plot-conflict":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-i","--intrees", action="store", default=None)
		qs_parser.add_argument("-g", "--outgroup", action="store", default="none")
		qs_parser.add_argument("-l", "--lineagefile", action="store", default="none")
		qs_parser.add_argument("-q", "--quartetfile", action="store", default=None)
		qs_parser.add_argument("-e", "--level", action="store", default="none")
		qs_parser.add_argument("-s", "--seed", action="store", default="random") 
		qs_parser.add_argument("-r", "--treelist", action="store", default=None)
		qs_parser.add_argument("--quiet", action="store_true", default=False) 
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help: 
			print(help_message(util_plot_conflict_help))
			sys.exit(0)
		if not qs_args.intrees:
			print(now(),"Hint: No input trees specified")
			print(help_message(util_plot_conflict_help))
			sys.exit(1)
		elif len(qs_args.intrees.split(",")) != 2:
			print(now(), "Hint: Need exactly two trees for comparison, seperated by a comma (,).")
			sys.exit(1)
		else:
			all_trees = qs_args.intrees	
		if not qs_args.quartetfile:
			print(now(), "Hint: You need to provide a quartet conflict file.")
			sys.exit(1)
		if not qs_args.treelist:
			print(now(), "Hint: You need to provide the treelist file.")
			sys.exit(1)
		
		cmd = ["singularity", "exec", "-B", os.getcwd(), get_container("rphylo"), "Rscript", "bin/plot-conflict.R"]
		cmd += [os.getcwd(), qs_args.seed, all_trees, qs_args.outgroup, qs_args.lineagefile, qs_args.level, qs_args.quartetfile, qs_args.treelist]

		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, not qs_args.quiet, config=None):
			print(line, end="\r")
	if which_util == "plot-heatmap":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-m","--simmatrix", action="store", default=None)
		qs_parser.add_argument("-r", "--treelist", action="store", default="none")
		qs_parser.add_argument("-d", "--decimalplaces", action="store", type=int, default=2, choices=range(0,15))
		qs_parser.add_argument("--quiet", action="store_true", default=False)
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help: 
			print(help_message(util_plot_similarity_help))
			sys.exit(0)
		if not qs_args.simmatrix:
			print(now(), "Hint: You have to provide the similarity matrix file created with phylociraptor util estimate-conflict with -m/--simmatrix")
			print(help_message(util_plot_similarity_help))
			sys.exit(1)	
		cmd = ["singularity", "exec", "-B", os.getcwd(), get_container("rphylo"), "Rscript", "bin/plot-heatmap.R", os.getcwd(), qs_args.simmatrix, qs_args.treelist, str(qs_args.decimalplaces)]
		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, not qs_args.quiet, config=None):
			print(line, end="\r")
	if which_util == "plot-pca":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-r", "--treelist", action="store", default="none")
		qs_parser.add_argument("--quiet", action="store_true", default=False)
		qs_parser.add_argument("-t", "--threads", action="store", default="1") 
		qs_parser.add_argument("-n", "--ndistances", action="store", default="all")
		qs_parser.add_argument("-s", "--seed", action="store", default="random")
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help: 
			print(help_message(util_plot_pca_help))
			sys.exit(0)
		if qs_args.treelist == "none":
			print(now(), "You have to provide the treelist file created with phylociraptor util estimate-conflict with -r/--treelist")
			print(help_message(util_plot_pca_help))
			sys.exit(1)	
		cmd = ["singularity", "exec", "-B", os.getcwd(), get_container("rphylo"), "Rscript", "bin/plot-t2t-pca.R", os.getcwd(), qs_args.treelist, qs_args.threads, qs_args.ndistances, qs_args.seed]
		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, not qs_args.quiet, config=None):
			print(line, end="\r")
	if which_util == "modify-busco":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-n","--ngenes", action="store", default=None)
		qs_parser.add_argument("-g", "--genes", action="store", default="none")
		qs_parser.add_argument("-b", "--buscoset", action="store", default=None)
		qs_parser.add_argument("--quiet", action="store_true", default=False)
		qs_parser.add_argument("-s", "--seed", action="store", default="random")
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help:
			print(help_message(util_modify_busco_help))
			sys.exit(0)
		if not qs_args.ngenes and qs_args.genes == "none":
			print("Hint: You have to specify -n or -g to use this function.")
			print(help_message(util_modify_busco_help))
			sys.exit(1)
		if qs_args.ngenes and qs_args.genes != "none":
			print("Hint: You have to specify either -n or -g. Not both.")
			sys.exit(1)
		if not qs_args.buscoset:
			print("Hint: A BUSCO set name needs to be specified.")
			sys.exit(1)
		if qs_args.ngenes:
			first_arg = "ngenes="+qs_args.ngenes
		if qs_args.genes and qs_args.genes != "none":
			first_arg = "genes="+qs_args.genes
		cmd = ["bash", "bin/modify-busco.sh", first_arg, qs_args.buscoset, qs_args.seed]
		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, not qs_args.quiet, config=None):
			print(line, end="\r")
	if which_util == "manage-jobs":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-f","--logfile", action="store", default=None)
		qs_parser.add_argument("-c", "--cancel", action="store_true", default=False)
		qs_parser.add_argument("-q", "--quiet", action="store_true", default=False)
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help:
			print(help_message(util_manage_jobs_help))
			sys.exit(0)
		if not qs_args.logfile:
			list_of_files = glob.glob('log/phylociraptor/*')
			lf = max(list_of_files, key=os.path.getctime)
			print("No logfile specified. Will use the latest logfile:", lf)
			qs_args.logfile = lf
		cmd = ["python3", "bin/parse-log.py", "-f", qs_args.logfile, "-l"]
		if qs_args.cancel:
			cmd += ["--cancel"] 
		if qs_args.verbose:
			cmd += ["--verbose"]
		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, not qs_args.quiet, None, True):
			print(line, end="\r")
	if which_util == "tracecomp":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-x","--burnin", action="store", default=None)
		qs_parser.add_argument("-p", "--path", action="store", default=None)
		qs_parser.add_argument("-o","--outfile", action="store", default=None)
		qs_parser.add_argument("--chains", action="store", default=None)
		qs_parser.add_argument("--config-file", dest="configfile", action="store", default="data/config.yaml")
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help:
			print(help_message(util_tracecomp_help))
			sys.exit(0)
		hashes= {}
		hashes["bitree"] = collect_hashes("bitree", parse_config_file(qs_args.configfile), qs_args.configfile, debug=qs_args.debug, wd=os.getcwd())

		parameters = parse_config_file(qs_args.configfile)
		if not qs_args.path:
			print(now(), "Will search for phylobayes output folders according to values provided in config file:", qs_args.configfile)
			folderlist = []
			for al in parameters["alignment"]["method"]:
				for tr in parameters["trimming"]["method"]:
					for bs in parameters["genetree_filtering"]["bootstrap_cutoff"]:
						folderlist.append("results/phylogeny/phylobayes/bootstrap-cutoff-" + str(bs) + "/" + al + "-" + tr + "." + hashes["bitree"]["bitree"]["per"][str(bs)]["phylobayes"]["iqtree"][tr][al]+"/")
			print(now(), "Found "+ str(len(folderlist)) +" folders with phylobayes results.")
		else:
			print(now(), "Will search for phylobayes output in:", qs_args.path)
			folderlist.append(qs_args.path)
		tracefiles=[]
		for folder in folderlist:
			tracefiles += glob.glob(folder + "chain-*/*.trace")
		if qs_args.chains:
			print(now(), "Will only analyse chains:", qs_args.chains)
			whichchains = ["chain-" + chain for chain in qs_args.chains.split(",")]
			tracefiles = [tracefile for chain in whichchains for tracefile in tracefiles if chain in tracefile]
				
		print(now(), "Found "+ str(len(tracefiles)) +" trace files from phylobayes.")
		cmd = ["singularity", "exec", "-B", os.getcwd(), get_container("phylobayes"), "tracecomp"] 
		if qs_args.burnin:
			print(now(), "Will use provided burnin:", qs_args.burnin)
			cmd += ["-x", qs_args.burnin]
		if qs_args.outfile:
			print(now(), "Will write output to file:", qs_args.outfile, ".contdiff")
			cmd += ["-o", qs_args.outfile]
		cmd += tracefiles
		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, False, None, True):
			print(line, end="\r")
	if which_util == "bpcomp":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-c","--cutoff", action="store", default=None)
		qs_parser.add_argument("-x", "--burnin", action="store", default=None)
		qs_parser.add_argument("-o","--outfile", action="store", default=None)
		qs_parser.add_argument("-p", "--path", action="store", default=None)
		qs_parser.add_argument("--chains", action="store", default=None)
		qs_parser.add_argument("--config-file", dest="configfile", action="store", default="data/config.yaml")
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help:
			print(help_message(util_tracecomp_help))
			sys.exit(0)
		hashes= {}
		hashes["bitree"] = collect_hashes("bitree", parse_config_file(qs_args.configfile), qs_args.configfile, debug=qs_args.debug, wd=os.getcwd())

		parameters = parse_config_file(qs_args.configfile)
		if not qs_args.path:
			print(now(), "Will search for phylobayes output folders according to values provided in config file:", qs_args.configfile)
			folderlist = []
			for al in parameters["alignment"]["method"]:
				for tr in parameters["trimming"]["method"]:
					for bs in parameters["genetree_filtering"]["bootstrap_cutoff"]:
						folderlist.append("results/phylogeny/phylobayes/bootstrap-cutoff-" + str(bs) + "/" + al + "-" + tr + "." + hashes["bitree"]["bitree"]["per"][str(bs)]["phylobayes"]["iqtree"][tr][al]+"/")
			print(now(), "Found "+ str(len(folderlist)) +" folders with phylobayes results.")
		else:
			print(now(), "Will search for phylobayes output in:", qs_args.path)
			folderlist.append(qs_args.path)
		treefiles=[]
		for folder in folderlist:
			treefiles += glob.glob(folder + "chain-*/*.treelist")
		if qs_args.chains:
			print(now(), "Will only analyse chains:", qs_args.chains)
			whichchains = ["chain-" + chain for chain in qs_args.chains.split(",")]
			treefiles = [treefile for chain in whichchains for treefile in treefiles if chain in treefile]
		print(now(), "Found "+ str(len(treefiles)) +" treelist files from phylobayes.")
		cmd = ["singularity", "exec", "-B", os.getcwd(), get_container("phylobayes"), "bpcomp"] 
		if qs_args.burnin:
			print(now(), "Will use provided burnin:", qs_args.burnin)
			cmd += ["-x", qs_args.burnin]
		if qs_args.cutoff:
			print(now(), "Will use provided partition probability cutoff:", qs_args.burnin)
			cmd += ["-c", qs_args.cutoff]
		if qs_args.outfile:
			print(now(), "Will write output to file:", qs_args.outfile + ".con.tre and", qs_args.outfile + ".bplist")
			cmd += ["-o", qs_args.outfile]
		else:
			folder = set(folderlist)
			if len(folder) == 1:
				folder = next(iter(folder))
				print(now(), "Will write output to file:", folder+ "phylobayes.con.tre and", folder + "phylobayes.bplist")
				cmd += ["-o", folder+"phylobayes"]
		cmd += treefiles
		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, False, None, True):
			print(line, end="\r")
	if which_util == "viewtrace":
		qs_parser = UtilParser(add_help=False)
		qs_parser.add_argument("-x", "--burnin", action="store", default=None)
		qs_parser.add_argument("-o","--outfile", action="store", default=None)
		qs_parser.add_argument("-p", "--path", action="store", default=None)
		qs_parser.add_argument("--chains", action="store", default=None)
		qs_parser.add_argument("--config-file", dest="configfile", action="store", default="data/config.yaml")
		qs_args = qs_parser.parse_args(args.arguments) 
		if qs_args.help:
			print(help_message(util_tracecomp_help))
			sys.exit(0)
		hashes= {}
		hashes["bitree"] = collect_hashes("bitree", parse_config_file(qs_args.configfile), qs_args.configfile, debug=qs_args.debug, wd=os.getcwd())

		parameters = parse_config_file(qs_args.configfile)
		if not qs_args.path:
			print(now(), "Will search for phylobayes output folders according to values provided in config file:", qs_args.configfile)
			folderlist = []
			for al in parameters["alignment"]["method"]:
				for tr in parameters["trimming"]["method"]:
					for bs in parameters["genetree_filtering"]["bootstrap_cutoff"]:
						folderlist.append("results/phylogeny/phylobayes/bootstrap-cutoff-" + str(bs) + "/" + al + "-" + tr + "." + hashes["bitree"]["bitree"]["per"][str(bs)]["phylobayes"]["iqtree"][tr][al]+"/")
			print(now(), "Found "+ str(len(folderlist)) +" folders with phylobayes results.")
		else:
			print(now(), "Will search for phylobayes output in:", qs_args.path)
			folderlist.append(qs_args.path)
		tracefiles=[]
		for folder in folderlist:
			tracefiles += glob.glob(folder + "chain-*/*.trace")
		if qs_args.chains:
			print(now(), "Will only analyse chains:", qs_args.chains)
			whichchains = ["chain-" + chain for chain in qs_args.chains.split(",")]
			tracefiles = [tracefile for chain in whichchains for tracefile in tracefiles if chain in tracefile]
				
		print(now(), "Found "+ str(len(tracefiles)) +" trace files from phylobayes.")
		cmd = ["singularity", "exec", "-B", os.getcwd(), get_container("gnuplot"), "gnuplot", "-p", "-e", "'set", "terminal", "dumb", "size", "120,", "30;", "set", "autoscale;", "plot", "\'-\'", "using", "1:4", "with", "lines", "notitle'"] 
		if qs_args.burnin:
			print(now(), "Will use provided burnin:", qs_args.burnin)
			cmd += ["-x", qs_args.burnin]
		if qs_args.outfile:
			print(now(), "Will write output to file:", qs_args.outfile, ".contdiff")
			cmd += ["-o", qs_args.outfile]
		cmd += tracefiles
		if debug and qs_args.verbose:
			print(cmd)
		for line in execute_command(cmd, False, None, True):
			print(line, end="\r")
else:
	print("Runmode not recognized: %s" % args.command)
	print("Please run phylociraptor -h to see avilable options.")

